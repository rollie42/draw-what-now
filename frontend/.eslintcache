[{"/mnt/c/Users/Rollie/Documents/Repos/drawing-app/web-client/src/index.js":"1","/mnt/c/Users/Rollie/Documents/Repos/drawing-app/web-client/src/App.js":"2","/mnt/c/Users/Rollie/Documents/Repos/drawing-app/web-client/src/reportWebVitals.js":"3","/home/rollie/repos/drawing-app/frontend/src/index.js":"4","/home/rollie/repos/drawing-app/frontend/src/App.js":"5","/home/rollie/repos/drawing-app/frontend/src/reportWebVitals.js":"6","/home/rollie/repos/drawing-app/frontend/src/GameApi.js":"7","/home/rollie/repos/drawing-app/frontend/src/Context.js":"8","/home/rollie/repos/drawing-app/frontend/src/Components/MainContainer.js":"9","/home/rollie/repos/drawing-app/frontend/src/Components/DrawingControls.js":"10","/home/rollie/repos/drawing-app/frontend/src/Components/GameStateDetails.js":"11","/home/rollie/repos/drawing-app/frontend/src/Components/TaskList.js":"12","/home/rollie/repos/drawing-app/frontend/src/Components/TopBar.js":"13","/home/rollie/repos/drawing-app/frontend/src/Components/CanvasArea.js":"14","/home/rollie/repos/drawing-app/frontend/src/Components/GameDialogs.js":"15","/home/rollie/repos/drawing-app/frontend/src/Controls.js":"16","/home/rollie/repos/drawing-app/frontend/src/Components/Canvas.js":"17","/home/rollie/repos/drawing-app/frontend/src/Utils.js":"18","/home/rollie/repos/drawing-app/frontend/src/GameState.js":"19","/home/rollie/repos/drawing-app/frontend/src/Components/GameSummary.js":"20"},{"size":500,"mtime":1609688572108,"results":"21","hashOfConfig":"22"},{"size":1016,"mtime":1609689164612,"results":"23","hashOfConfig":"22"},{"size":362,"mtime":1609682238588,"results":"24","hashOfConfig":"22"},{"size":500,"mtime":1609690002390,"results":"25","hashOfConfig":"26"},{"size":2364,"mtime":1611677105970,"results":"27","hashOfConfig":"26"},{"size":362,"mtime":1609690002410,"results":"28","hashOfConfig":"26"},{"size":2201,"mtime":1611633978040,"results":"29","hashOfConfig":"26"},{"size":4807,"mtime":1611666582960,"results":"30","hashOfConfig":"26"},{"size":467,"mtime":1611628503190,"results":"31","hashOfConfig":"26"},{"size":12447,"mtime":1611666258470,"results":"32","hashOfConfig":"26"},{"size":6184,"mtime":1611676807620,"results":"33","hashOfConfig":"26"},{"size":1658,"mtime":1611639812580,"results":"34","hashOfConfig":"26"},{"size":6203,"mtime":1611666444210,"results":"35","hashOfConfig":"26"},{"size":9789,"mtime":1611670382690,"results":"36","hashOfConfig":"26"},{"size":3582,"mtime":1611673677390,"results":"37","hashOfConfig":"26"},{"size":340,"mtime":1610811531190,"results":"38","hashOfConfig":"26"},{"size":18228,"mtime":1611667024930,"results":"39","hashOfConfig":"26"},{"size":90,"mtime":1611398781154,"results":"40","hashOfConfig":"26"},{"size":470,"mtime":1611676998910,"results":"41","hashOfConfig":"26"},{"size":1414,"mtime":1611715859120,"results":"42","hashOfConfig":"26"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"45"},"l6gboe",{"filePath":"46","messages":"47","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"45"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},"tp3nf3",{"filePath":"53","messages":"54","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61","usedDeprecatedRules":"52"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"66","usedDeprecatedRules":"52"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"69","messages":"70","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71","usedDeprecatedRules":"52"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"74","usedDeprecatedRules":"52"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"77","messages":"78","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"79","messages":"80","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"81","messages":"82","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"83","usedDeprecatedRules":"52"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"88","messages":"89","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/mnt/c/Users/Rollie/Documents/Repos/drawing-app/web-client/src/index.js",[],["90","91"],"/mnt/c/Users/Rollie/Documents/Repos/drawing-app/web-client/src/App.js",["92"],"/mnt/c/Users/Rollie/Documents/Repos/drawing-app/web-client/src/reportWebVitals.js",[],"/home/rollie/repos/drawing-app/frontend/src/index.js",[],["93","94"],"/home/rollie/repos/drawing-app/frontend/src/App.js",["95","96"],"/home/rollie/repos/drawing-app/frontend/src/reportWebVitals.js",[],"/home/rollie/repos/drawing-app/frontend/src/GameApi.js",[],"/home/rollie/repos/drawing-app/frontend/src/Context.js",["97"],"import React, { useEffect } from 'react';\nimport { DrawingMode } from './Components/Canvas'\nimport GameState from './GameState'\nimport Cookies from 'js-cookie'\n\nexport const UserContext = React.createContext()\nexport const ActiveBookContext = React.createContext()\nconst defaultColor = \"rgba(255, 0, 0, 1)\"\nexport const ActiveColorContext = React.createContext(defaultColor)\nexport const ColorPalette = React.createContext([])\nexport const BrushWidthContext = React.createContext(1)\nexport const TasksContext = React.createContext([])\nexport const GameStateContext = React.createContext(null)\nexport const ActiveToolContext = React.createContext(DrawingMode.DRAW)\nexport const ActiveShapeContext = React.createContext(DrawingMode.DRAW_SQUARE)\nexport const FillShapeContext = React.createContext(true)\nexport const DescriptionContext = React.createContext(\"\")\nexport const DisplayedImageContext = React.createContext(\"\")\nexport const ReplayDrawingsContext = React.createContext([])\nexport const RequestClearContext = React.createContext(false)\n\nexport function AppContextProvider(props) {\n    const [user, setUser] = React.useState(null)\n    const setUserWrapper = (u) => {\n\n        if (u)\n            Cookies.set(\"user\", u)\n        else\n            Cookies.remove(\"user\")\n        setUser(u)\n    }\n    const [activeBook, setActiveBook] = React.useState(null)\n    const [activeColor, setActiveColor] = React.useState(defaultColor)\n    const [colorPalette, setColorPalette] = React.useState([])\n    const [brushWidth, setBrushWidth] = React.useState(1)\n    const [tasks, setTasks] = React.useState([])\n    const [gameState, setGameState] = React.useState(null)\n    const setGameStateWrapper = (gs) => {\n        console.log(gs)\n        if (gs) {\n            Cookies.set(\"gameState\", gs)\n            setGameState(new GameState(gs))\n        } else {\n            Cookies.remove(\"gameState\")\n            setGameState(undefined)\n        }\n\n    }\n    const [activeTool, setActiveTool] = React.useState(DrawingMode.DRAW)\n    const [activeShape, setActiveShape] = React.useState(DrawingMode.DRAW_SQUARE)\n    const [fillShape, setFillShape] = React.useState(true)\n    const [description, setDescription] = React.useState(\"\")\n    const [displayedImage, setDisplayedImage] = React.useState(\"\")\n    const [replayDrawings, setReplayDrawings] = React.useState([])\n    const [requestClear, setRequestClear] = React.useState(false)\n\n    return (\n        <UserContext.Provider value={[user, setUserWrapper]}>\n            <ActiveBookContext.Provider value={[activeBook, setActiveBook]}>\n                <ActiveColorContext.Provider value={[activeColor, setActiveColor]}>\n                    <ColorPalette.Provider value={[colorPalette, setColorPalette]}>\n                        <BrushWidthContext.Provider value={[brushWidth, setBrushWidth]}>\n                            <TasksContext.Provider value={[tasks, setTasks]}>\n                                <GameStateContext.Provider value={[gameState, setGameStateWrapper]}>\n                                    <ActiveToolContext.Provider value={[activeTool, setActiveTool]}>\n                                        <ActiveShapeContext.Provider value={[activeShape, setActiveShape]}>\n                                            <FillShapeContext.Provider value={[fillShape, setFillShape]}>\n                                                <DescriptionContext.Provider value={[description, setDescription]}>\n                                                    <DisplayedImageContext.Provider value={[displayedImage, setDisplayedImage]}>\n                                                        <ReplayDrawingsContext.Provider value={[replayDrawings, setReplayDrawings]}>\n                                                            <RequestClearContext.Provider value={[requestClear, setRequestClear]}>\n                                                                {props.children}\n                                                            </RequestClearContext.Provider>\n                                                        </ReplayDrawingsContext.Provider>\n                                                    </DisplayedImageContext.Provider>\n                                                </DescriptionContext.Provider>\n                                            </FillShapeContext.Provider>\n                                        </ActiveShapeContext.Provider>\n                                    </ActiveToolContext.Provider>\n                                </GameStateContext.Provider>\n                            </TasksContext.Provider>\n                        </BrushWidthContext.Provider>\n                    </ColorPalette.Provider>\n                </ActiveColorContext.Provider>\n            </ActiveBookContext.Provider>\n\n        </UserContext.Provider>\n    )\n}\n\n","/home/rollie/repos/drawing-app/frontend/src/Components/MainContainer.js",[],"/home/rollie/repos/drawing-app/frontend/src/Components/DrawingControls.js",["98","99","100","101"],"import React, { useEffect } from 'react'\nimport styled from 'styled-components'\nimport * as Context from '../Context'\nimport ToggleButton from '@material-ui/lab/ToggleButton';\nimport ToggleButtonGroup from '@material-ui/lab/ToggleButtonGroup';\nimport {sleep} from '../Utils'\nimport { DrawingMode } from './Canvas'\nimport { RgbaStringColorPicker } from \"react-colorful\";\nimport \"react-colorful/dist/index.css\"\n\nimport PaintBrushImg from '../images/paint-brush.png'\nimport ShapeToolImg from '../images/shape-tool.png'\nimport LineToolImg from '../images/line-tool.png'\nimport PaintBucketImg from '../images/paint-bucket.png'\nimport EraserImg from '../images/eraser.png'\nimport SelectRegion from '../images/select-region.png'\nimport Hand from '../images/hand.png'\n\nconst Container = styled.div`\n    min-width: 28vh;\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n`\n\nconst ControlPanel = styled.div`\n    background-color: #080808aa;\n    color: #e6e6e6;\n    width: 25vh;\n    padding: 20px 10px;\n    margin: 30px 50px;\n    min-height: 80%;\n`\n\nconst SVG = styled.svg`\n    display: inline-flex;\n    width: 30px;\n    height: 30px;\n    margin: 0px 2px;\n    padding: 3px;\n    ${props => props.selected && `background-color: #222222;`}\n`\n\nconst getRGB = (hexColor) => {\n    var match = hexColor.match(/rgba?\\((\\d{1,3}), ?(\\d{1,3}), ?(\\d{1,3})\\)?(?:, ?(\\d(?:\\.\\d+)?)\\))?/);\n    return match ? {\n        red: match[1],\n        green: match[2],\n        blue: match[3],\n        alpha: match[4]\n    } : {};\n}\n\nfunction colorsEqual(c1, c2) {\n    const o1 = getRGB(c1)\n    const o2 = getRGB(c2)\n    return o1.red === o2.red && o1.green === o2.green && o1.blue === o2.blue && Math.abs(o1.alpha - o2.alpha) < .1\n}\n\nfunction ColorCircle(props) {\n    const [activeColor, setActiveColor] = React.useContext(Context.ActiveColorContext)\n    const [colorPalette, setColorPalette] = React.useContext(Context.ColorPalette)\n    \n    const clickHandler = React.useCallback((e) => {\n        e.preventDefault()\n        if (e.type === \"click\")\n            setActiveColor(props.color)\n        else if (e.type === 'contextmenu')\n            setColorPalette(colorPalette.filter(color => color != props.color))\n    }, [colorPalette, activeColor])\n    return (\n        <SVG onContextMenu={clickHandler} onClick={clickHandler} selected={colorsEqual(activeColor, props.color)}>\n            <circle cx=\"15\" cy=\"15\" r=\"15\" stroke={props.color} strokeWidth=\"1\" fill={props.color} />\n        </SVG>\n    )\n}\n\nconst ColorCircleContainer = styled.div`\n    display: flex;\n    justify-content: left;\n    align-items: center;\n    min-height: 30px;\n    flex-wrap: wrap;\n`\nconst ColorPaletteContainer = styled.div`\n    margin-top: 8px;\n`\n\nconst Label = styled.div`\n`\n\nconst ClearButtonStyled = styled.button`\n`\n\nfunction ClearButton() {\n    const [, setRequestClear] = React.useContext(Context.RequestClearContext)\n\n    return (\n        <ClearButtonStyled onClick={() => setRequestClear(true)}>Clear canvas</ClearButtonStyled>\n    )\n}\nfunction ColorPalette() {\n    const [colorPalette] = React.useContext(Context.ColorPalette)\n\n    return (\n        <ColorPaletteContainer>\n            <Label>Palette</Label>\n            <ColorCircleContainer>\n                {colorPalette.map((value) => {\n                    return <ColorCircle key={value} color={value} />\n                })}\n            </ColorCircleContainer>\n        </ColorPaletteContainer>\n    )\n}\n\nconst StrokeWidthContainer = styled.div`\n`\n\nconst StrokeWidthValue = styled.input`\n    width: 20px;\n`\n\nfunction StrokeWidth() {\n    const [brushWidth, setBrushWidth] = React.useContext(Context.BrushWidthContext)\n\n    const handler = (e) => {\n        const val = e.target.value\n        setBrushWidth(val)\n    }\n    return (\n        <StrokeWidthContainer>\n            <Label>Stroke width</Label>\n            <StrokeWidthValue value={brushWidth} inputmode=\"numeric\" min=\"1\" max=\"72\" onChange={handler}></StrokeWidthValue>\n        </StrokeWidthContainer>\n    )\n}\n\nconst LabelContainer = styled.div`\n    font-size: 30px;\n    display: inline-block;\n    width: 100%;\n    margin: 0px 30px 32px 0px;\n    text-align: right;\n    transform: translate(-60px, 0px);\n    opacity: 0;\n    padding: 30px 0px;    \n\n    &.showing {\n        transition: transform 0.75s ease;\n        transform: translate(0px, 0px);\n        opacity: 1;\n    }\n\n    &.hiding {\n        transition: opacity 0.5s;\n        opacity: 0;        \n        transform: translate(0px, 0px);\n    }\n`\n\nfunction DescriptionLabel() {\n    const [gameState] = React.useContext(Context.GameStateContext)\n    const [, setDescription] = React.useContext(Context.DescriptionContext)\n    const [label, setLabel] = React.useState(\"\")\n    const [className, setClassName] = React.useState(\"\")\n\n    var name = \"\"\n    if (gameState) {\n        const presentationState = gameState.presentationState\n        const book = gameState.books?.find(b => b.creator.name === presentationState.bookOwner)\n        var entry = book?.entries[presentationState.pageNumber]\n        if (entry?.imageUrl)\n            entry = book.entries[presentationState.pageNumber - 1]\n\n        name = entry?.author?.name\n    }\n\n    useEffect(() => {\n        console.log(gameState)\n        const handler = async () => {\n            const newLabel = `${name} wrote:`\n            if (newLabel !== label) {\n                // Fade old text out\n                setClassName('hiding')\n                await sleep(500)          \n                setClassName('')\n                // Update text, slide in\n                setLabel(newLabel)\n                await sleep(200)\n                setClassName('showing')\n\n                await sleep(800)\n                setDescription(entry.description)\n            }\n        }\n\n        handler()\n    }, [entry.description, gameState, label, name])\n\n    return (\n        <LabelContainer className={className}>\n            <span>{label}</span>\n        </LabelContainer>\n    )\n}\n\nfunction ImageLabel() {\n    const [gameState] = React.useContext(Context.GameStateContext)\n    const [, setDisplayedImage] = React.useContext(Context.DisplayedImageContext)\n    const [label, setLabel] = React.useState(\"\")\n    const [className, setClassName] = React.useState(\"\")\n    \n    const presentationState = gameState.presentationState\n    // const book = gameState.books.find(b => b.creator.name === presentationState.bookOwner)\n\n    var name = \"\"\n    if (gameState) {\n        const presentationState = gameState.presentationState\n        const book = gameState.books.find(b => b.creator.name === presentationState.bookOwner)\n        var entry = book.entries[presentationState.pageNumber]\n        if (entry.description && presentationState.pageNumber > 0)\n            entry = book.entries[presentationState.pageNumber - 1]\n\n        name = entry?.author?.name\n    }\n\n    useEffect(() => {\n        const handler = async () => {\n            const newLabel = `${name} drew:`\n            \n            if (presentationState.pageNumber === 0) {\n                setDisplayedImage(entry.imageUrl)\n                setLabel(\"\")\n            } else if (newLabel !== label) {\n                // Fade old text out\n                setClassName('hiding')\n                await sleep(500)          \n                setClassName('')\n                // Update text, slide in\n                setLabel(newLabel)\n                await sleep(200)\n                setClassName('showing')\n\n                await sleep(800)\n                setDisplayedImage(entry.imageUrl)\n            }\n        }\n\n        handler()\n    }, [entry.imageUrl, gameState, label, name, presentationState.pageNumber])\n\n    return (\n        <LabelContainer className={className}>\n            {presentationState.pageNumber > 0 && <span>{label}</span>}\n        </LabelContainer>\n    )\n}\n\nconst BookTitleContainer = styled.div`    \n    font-family: 'Shadows Into Light', cursive;\n    font-size: 68px;\n    position: fixed;\n    color: #7F0037;\n    transform: translate(130px, -15px) rotate(-18deg);    \n`\n\nfunction BookTitle() {\n    const [gameState] = React.useContext(Context.GameStateContext)\n    const presentationState = gameState.presentationState\n    return (\n        <BookTitleContainer>{presentationState.bookOwner}'s Book</BookTitleContainer>\n    )\n}\n\nconst DeadSpace = styled.div`\n    flex: 1;\n`\n\nconst DeadSpaceTop = styled.div`\n    flex: 1;\n`\n\nconst ToggleButtonStyled = styled(ToggleButton)`\n`\n\nconst ToggleButtonImage = styled.img`\n    width: 26px;\n    height: 26px;\n`    \n\nconst ToggleButtonGroupStyled = styled(ToggleButtonGroup)`\n    display: flex;\n    flex-wrap: wrap;\n`\n\nfunction ToolSelector() {\n    const [activeTool, setActiveTool] = React.useContext(Context.ActiveToolContext);\n    return (\n        <ToggleButtonGroupStyled value={activeTool} exclusive onChange={(event, newTool) => newTool && setActiveTool(newTool)}>\n            <ToggleButtonStyled value={DrawingMode.DRAW}>\n                <ToggleButtonImage src={PaintBrushImg} />\n            </ToggleButtonStyled>\n            <ToggleButtonStyled value={'draw-shape'} >\n                <ToggleButtonImage src={ShapeToolImg} />\n            </ToggleButtonStyled>\n            <ToggleButtonStyled value={DrawingMode.DRAW_LINE} >\n                <ToggleButtonImage src={LineToolImg} />\n            </ToggleButtonStyled>\n            <ToggleButtonStyled value={DrawingMode.FILL} >\n                <ToggleButtonImage src={PaintBucketImg} />\n            </ToggleButtonStyled>\n            <ToggleButtonStyled value={DrawingMode.ERASE} >\n                <ToggleButtonImage src={EraserImg} />\n            </ToggleButtonStyled>\n            <ToggleButtonStyled value={DrawingMode.SELECT} >\n                <ToggleButtonImage src={SelectRegion} />\n            </ToggleButtonStyled>\n            <ToggleButtonStyled value={DrawingMode.MOVE} >\n                <ToggleButtonImage src={Hand} />\n            </ToggleButtonStyled>\n        </ToggleButtonGroupStyled>\n    )\n}\n\nconst Select = styled.select`\n`\n\nconst ShapeOptionsContainer = styled.div`    \n    overflow: hidden;\n    ${({ state }) => (state === \"exited\") ? `\n        max-height: 0px;\n        transition: max-height .4s ease-in-out;` : `\n    \n        max-height: 200px;\n        transition: max-height .7s ease-in-out;`\n    };\n`\nconst Checkbox = styled.input.attrs({ type: 'checkbox'})`\n`\n\nfunction ShapeSelector() {\n    const [activeTool] = React.useContext(Context.ActiveToolContext)\n    const [activeShape, setActiveShape] = React.useContext(Context.ActiveShapeContext)\n    const [fillShape, setFillShape] = React.useContext(Context.FillShapeContext)\n    const options = [\n        { label: 'Square', value: DrawingMode.DRAW_SQUARE},\n        { label: 'Circle', value: DrawingMode.DRAW_CIRCLE},\n        { label: 'Triangle', value: DrawingMode.DRAW_TRIANGLE}\n    ]\n    const setter = (evt) => {setActiveShape(evt.target.value) }\n    return (        \n        <ShapeOptionsContainer state={activeTool === 'draw-shape' ? 'show' : 'exited'}>\n            <label>Shape</label>\n            <div>\n                <Select value={activeShape} onChange={setter} >\n                    {options.map(o => <option key={o.value} value={o.value}>{o.label}</option>)}\n                </Select>\n                <Checkbox checked={fillShape} onChange={event => setFillShape(event.target.checked)} />\n                <label>Fill?</label>\n            </div>         \n\n\n        </ShapeOptionsContainer>\n    )\n}\n\nconst ColorPicker = styled(RgbaStringColorPicker)`\n    width: 100%;\n`\n\nexport default function DrawingControls() {\n    const [activeColor, setActiveColor] = React.useContext(Context.ActiveColorContext)\n    const [gameState] = React.useContext(Context.GameStateContext)\n    const presentingSummary = [\"PresentingSummary\"].includes(gameState?.gameStatus)\n\n    return (\n        <Container>\n            {![\"PresentingSummary\", \"Completed\"].includes(gameState?.gameStatus) && <ControlPanel>\n                <ToolSelector />\n                <ShapeSelector />\n                <StrokeWidth />\n                <ClearButton />\n                <ColorPicker color={activeColor} onChange={setActiveColor} />\n                <ColorPalette />                \n            </ControlPanel>}\n            {presentingSummary && <BookTitle />}\n            {presentingSummary && <DeadSpaceTop />}\n            {presentingSummary && <ImageLabel />}\n            {presentingSummary && <DeadSpace />}\n            {presentingSummary && <DescriptionLabel />}\n        </Container>\n    )\n}","/home/rollie/repos/drawing-app/frontend/src/Components/GameStateDetails.js",[],"/home/rollie/repos/drawing-app/frontend/src/Components/TaskList.js",["102"],"import React, { useContext } from 'react'\nimport styled from 'styled-components'\nimport Gesture from '@material-ui/icons/Gesture'\nimport TextFields from '@material-ui/icons/TextFields'\nimport * as Context from '../Context'\n\nconst TaskListContainer = styled.div`\n    height: 15vh;\n    background-color: #55555588;\n    display: flex;\n    align-items: center;\n`\n\nconst TaskContainer = styled.div`\n    background-color: #f8f8f8;\n    margin: 0px 15px;\n`\n\nfunction Task(props) {\n    const style = {\n        fontSize: 100,\n        color: props.active ? 'red' : 'black'\n    }\n    return (\n        <TaskContainer>\n            {props.drawing && <Gesture style={style} />}\n            {!props.drawing && <TextFields style={style} />}\n        </TaskContainer>\n    )\n}\n\nexport default function TaskList() {\n    const [gameState] = useContext(Context.GameStateContext)\n    const [user] = useContext(Context.UserContext)\n    const [activeBook, setActiveBook] = React.useContext(Context.ActiveBookContext)\n    const tasks = gameState?.books?.filter(book => book.actors && book.actors[0]?.name === user.name) ?? []\n\n    React.useEffect(() => {\n        if (!activeBook && gameState && gameState.books) {\n            const book = gameState.books.find(book => book.actors && book.actors[0]?.name === user.name)\n            if (book) {\n                setActiveBook(book)\n            }\n        }\n    }, [activeBook, gameState, user])\n\n    return (\n        <TaskListContainer>\n            {tasks.map(task => <Task key={task.creator.name} drawing={task?.entries?.length % 2 === 1} active={task?.creator?.name === activeBook?.creator?.name} />)}\n        </TaskListContainer>\n    )\n}","/home/rollie/repos/drawing-app/frontend/src/Components/TopBar.js",["103","104","105"],"import React from 'react'\nimport styled from 'styled-components'\nimport * as Context from '../Context'\nimport * as GameApi from '../GameApi'\nimport { JoinGameDialog, CreateGameDialog } from './GameDialogs'\nimport { Button } from '../Controls'\nimport HourglassEmpty from '@material-ui/icons/HourglassEmpty'\n\n\nconst TopControlContainer = styled.div`\n    display: flex;\n    align-items: center;\n    color: #dddddd;\n    font-size: 22px;\n`\n\nfunction JoinGame() {\n    const [open, setOpen] = React.useState(false)\n\n    return (\n        <TopControlContainer>\n            <Button onClick={() => setOpen(true)}>Join Game</Button>\n            <JoinGameDialog open={open} setOpen={setOpen} />\n        </TopControlContainer>\n    )\n}\n\nfunction CreateGame() {\n    const [open, setOpen] = React.useState(false)\n\n    return (\n        <TopControlContainer>\n            <Button onClick={() => setOpen(true)}>Create Game</Button>\n            <CreateGameDialog open={open} setOpen={setOpen} />\n        </TopControlContainer>\n    )\n}\n\nfunction ExitGame() {\n    const [, setGameState] = React.useContext(Context.GameStateContext)\n    const [, setUser] = React.useContext(Context.UserContext)\n    const clickHandler = () => {\n        setGameState(undefined)\n        setUser(undefined)\n    }\n\n    return (\n        <TopControlContainer>\n            <Button onClick={clickHandler}>Exit Game</Button>\n        </TopControlContainer>\n    )\n}\n\n\nfunction TestGame() {\n    const [gameState, setGameState] = React.useContext(Context.GameStateContext)\n    const [, setUser] = React.useContext(Context.UserContext)\n\n    const testFunc = async () => {\n        setUser(await GameApi.Login(\"bob\"))\n        const gs = await GameApi.GetFakeGame()\n        setGameState(gs)\n        return\n\n        const users = []\n        users.push(\n            await GameApi.Login(\"bob\"),\n            await GameApi.Login(\"sam\"),\n            await GameApi.Login(\"jenny\"),\n            await GameApi.Login(\"mark\"),\n            await GameApi.Login(\"takeshi\")\n        )\n\n        const creator = users[0]\n\n        setUser(creator)\n\n        const gameName = \"Test Game\" + Math.floor(Math.random() * Math.floor(10000))\n        console.log(\"creating game\")\n        var testGameState = await GameApi.CreateGame(gameName, creator)\n        setGameState(testGameState)\n\n        console.log(\"having users join game\")\n        for (const user of users) {\n            await GameApi.JoinGame(gameName, user)\n        }\n\n        console.log(\"starting game\")\n        testGameState = await GameApi.StartGame(testGameState.id, { rounds: 5 }, creator)\n        setGameState(testGameState)\n        const imageData = undefined\n\n        while (true) {\n            const book = testGameState.books.filter(b => b.actors[0])[0]\n            if (!book)\n                break\n\n            const user = book.actors[0]\n            if (book.entries.length % 2 === 0) { // describe\n                testGameState = await GameApi.UploadDescription(\"Test Description\" + book.entries.length, testGameState.id, book.creator.name, user)\n            } else { // draw\n                testGameState = await GameApi.UploadDrawing(imageData, testGameState.id, book.creator.name, user)\n            }\n        }\n\n        // console.log(\"submitting descriptions\")\n        // console.log(testGameState)\n        // for (const user of users) {//.filter(user => user.name != creator.name)) {\n        //     const book = testGameState.books.filter(book => book.actors[0]?.name == user.name)[0]\n        //     console.log(user.name, book?.actors[0]?.name, book)\n        //     if (book)\n        //         await GameApi.UploadDescription(\"Test Description\", testGameState.id, book.creator.name, user)\n        // }\n    }\n\n    return (\n        <TopControlContainer>\n            <Button onClick={testFunc}>Test Game</Button>\n        </TopControlContainer>\n    )\n}\n\nconst Container = styled.div`\n    width: 100%;\n    height: 50px;\n    background-color: #111111aa;\n    display: flex;\n    justify-content: flex-end;\n`\n\nconst DeadSpace = styled.div`\n    flex: 1;\n`\n\nconst SVG = styled.svg`\n    display: inline-flex;\n    width: 70px;\n    height: 70px;\n    margin: 0px 2px;\n    padding: 3px;\n    ${props => props.selected && `background-color: #222222;`}\n`\n\nconst HourGlassContainer = styled.div`\n    position: absolute;\n    left: 6px;\n    top: 2px;\n    font-size: 44px;\n`\n\n\nfunction HourGlass() {\n    const [gameState] = React.useContext(Context.GameStateContext)\n    const [user] = React.useContext(Context.UserContext)\n\n    const groupBy = (list, keyGetter) =>\n        list.reduce(function (r, a) {\n            r[keyGetter(a)] = r[keyGetter(a)] || [];\n            r[keyGetter(a)].push(a);\n            return r;\n        }, Object.create(null));\n\n    var color = \"green\"\n    console.log(gameState)\n    const entries = gameState.books.map(book => book.entries).flat().filter(entry => entry.imageUrl)\n    if (entries.length) {\n\n        const groups = groupBy(entries, entry => entry.author.name)\n        const imagesDone = Object.values(groups).map(arr => arr.length).sort()\n        const median = imagesDone[Math.floor(imagesDone.length / 2)]\n        const userCompleted = groups[user.name]?.length || 0\n        color = userCompleted >= median\n            ? \"green\"\n            : userCompleted >= median - 1\n                ? \"yellow\"\n                : \"red\"\n    }\n    const r = 35\n    const fontStyle = {\n        position: 'absolute',\n        left: 15,\n        top: 13,\n        color: \"#222222\",\n        fontSize: \"48px\"\n    }\n    return (\n        <HourGlassContainer>\n            <SVG>\n                <circle cx={r} cy={r} r={r} stroke={color} strokeWidth=\"1\" fill={color} />\n            </SVG>\n            <HourglassEmpty style={fontStyle} />\n        </HourGlassContainer>\n    )\n}\n\nexport default function TopBar() {\n    const [gameState] = React.useContext(Context.GameStateContext)\n    return (\n        <Container>\n            {gameState?.gameStatus === \"InProgress\" && <HourGlass />}\n            <DeadSpace />\n            {!gameState &&\n                <>\n                    <JoinGame />\n                    <CreateGame />\n                    <ExitGame />\n                </>\n            }\n\n        </Container>\n    )\n}","/home/rollie/repos/drawing-app/frontend/src/Components/CanvasArea.js",["106","107","108","109","110","111","112"],"/home/rollie/repos/drawing-app/frontend/src/Components/GameDialogs.js",[],"/home/rollie/repos/drawing-app/frontend/src/Controls.js",[],"/home/rollie/repos/drawing-app/frontend/src/Components/Canvas.js",["113","114","115","116","117","118","119"],"import React, { useEffect } from 'react'\nimport { sleep } from '../Utils'\nimport styled from 'styled-components'\nimport FloodFill from 'q-floodfill'\n\nexport const DrawingMode = {\n    DRAW: 'draw',\n    DRAW_SQUARE: 'draw-square',\n    DRAW_CIRCLE: 'draw-circle',\n    DRAW_TRIANGLE: 'draw-triangle',\n    DRAW_LINE: 'draw-line',\n    ERASE: 'erase',\n    FILL: 'fill',\n    DISABLED: 'disabled',\n    SELECT: 'select',\n    MOVE: 'move'\n}\n\nconst MouseEventType = {\n    UP: \"up\",\n    DOWN: \"down\",\n    MOVE: \"move\"\n}\n\nclass MouseEvent {\n    constructor(eventType, position, pen, pressure) {\n        this.eventType = eventType\n        this.position = position\n        this.pen = pen\n        this.pressure = pressure\n    }\n\n    up() { return this.eventType === MouseEventType.UP }\n    down() { return this.eventType === MouseEventType.DOWN }\n    move() { return this.eventType === MouseEventType.MOVE }\n}\n\nconst StyledCanvas = styled.canvas`\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n`\n\nconst clear = (canvas) => {\n    canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height)\n}\n\nconst _getPos = (canvas, event) => {\n    const rect = canvas.getBoundingClientRect()\n    const position = (event?.changedTouches && event.changedTouches[0]) || event\n    return { x: position.clientX - rect.left, y: position.clientY - rect.top }\n}\n\nconst mouseEvent = (canvas) => {\n    return new Promise((resolve, reject) => {\n        const makeHandler = type => event => {\n            if (event.type === 'pointerup' && event.button !== 0)\n                return\n\n            if (event.cancelable)\n                event.preventDefault()\n\n            canvas.removeEventListener('pointermove', moveHandler)\n            document.removeEventListener('pointerup', upHandler)\n            resolve(new MouseEvent(type, _getPos(canvas, event), event.pointerType === 'pen', event.pressure))\n        }\n\n        const moveHandler = makeHandler(MouseEventType.MOVE)\n        const upHandler = makeHandler(MouseEventType.UP)\n\n        canvas.addEventListener('pointermove', moveHandler)\n        document.addEventListener('pointerup', upHandler)\n    })\n}\n\nconst draw = async (drawParams) => {\n    console.log(drawParams)\n    const { startPoint, workingCanvas, layerCanvas, mode, fillShape, fakeDrawing } = drawParams\n    const workingContext = workingCanvas.getContext('2d')\n    const layerContext = layerCanvas.getContext('2d')\n\n    var fakePointIdx = 0\n    const fakeMouseEvent = async (startTime) => {\n        switch (mode) {\n            case DrawingMode.DRAW:\n            case DrawingMode.ERASE: {\n                const points = fakeDrawing.points\n\n                await sleep(.001)\n                fakePointIdx = Math.min(fakePointIdx + 2, points.length - 1)\n\n                return new MouseEvent(\n                    fakePointIdx === points.length - 1 ? MouseEventType.UP : MouseEventType.MOVE,\n                    points[fakePointIdx],\n                    false,\n                    1)\n            }\n            case DrawingMode.DRAW_SQUARE:\n            case DrawingMode.DRAW_CIRCLE:\n            case DrawingMode.DRAW_TRIANGLE:\n            case DrawingMode.DRAW_LINE: {\n                await sleep(1)\n                const t = Date.now() - startTime\n                const durationMs = 800\n                const pos = {\n                    x: startPoint.x + fakeDrawing.dx * t / durationMs,\n                    y: startPoint.y + fakeDrawing.dy * t / durationMs\n                }\n\n                return new MouseEvent(\n                    t >= durationMs ? MouseEventType.UP : MouseEventType.MOVE,\n                    pos,\n                    false,\n                    1)\n            }\n            case DrawingMode.FILL:\n            default:\n                break\n        }\n    }\n\n    const drawShape = async (drawFn) => {\n        const startTime = Date.now()\n        while (true) {\n            const mouseEvt = await (fakeDrawing ? fakeMouseEvent(startTime) : mouseEvent(workingCanvas))\n            const { pen, pressure, position } = mouseEvt\n            const dx = mouseEvt.position.x - startPoint.x\n            const dy = mouseEvt.position.y - startPoint.y\n\n            // clear temp canvas\n            clear(workingCanvas)\n            drawFn({\n                context: mouseEvt.up() ? layerContext : workingContext,\n                startPoint,\n                endPoint: position,\n                dx,\n                dy,\n                pen,\n                pressure\n            })\n\n            if (mouseEvt.up()) {\n                console.log(\"Done!\")\n                return\n            }\n        }\n    }\n\n    var drawing = {\n        drawParams,\n        color: workingContext.color,\n        lineWidth: workingContext.lineWidth,\n    }\n\n    switch (mode) {\n        case DrawingMode.DRAW:\n        case DrawingMode.ERASE:\n            var path = undefined\n            const paths = []\n            const points = [{ ...startPoint }]\n\n            const t = 1\n\n            await drawShape(({ context, endPoint, pen, pressure }) => {\n                if (mode === DrawingMode.ERASE)\n                    context = layerContext\n\n                var lineWidth = context.lineWidth\n                if (pen) {\n                    const x = Math.pow(Math.E, 2.03731 * pressure)\n                    const width = 11.2892 * x - 12.0045\n                    lineWidth = Math.min(Math.max(width, 1), 72)\n                }\n\n                points.push({ ...endPoint, lineWidth })\n\n                const i = points.length - 2\n                var p0 = (i > 0) ? points[i - 1] : points[0]\n                var p1 = points[i]\n                var p2 = points[i + 1] // This is the one we're going to\n                var p3 = (i !== points.length - 2) ? points[i + 2] : p2\n\n                if (!path || lineWidth !== path.lineWidth) {\n                    // line width changed - set up a new path\n                    path = new Path2D()\n                    path.lineWidth = lineWidth\n                    path.moveTo(p1.x, p1.y)\n                    paths.push(path)\n                }\n\n                var filledShape = false\n                if (points.length > 2 || (points.length === 2 && points[0].x !== points[1].x && points[0].y !== points[1].y)) {\n                    var cp1x = p1.x + (p2.x - p0.x) / 6 * t\n                    var cp1y = p1.y + (p2.y - p0.y) / 6 * t\n\n                    var cp2x = p2.x - (p3.x - p1.x) / 6 * t\n                    var cp2y = p2.y - (p3.y - p1.y) / 6 * t\n                    path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y)\n                } else {\n                    // draw  as a single point\n                    console.log('single point')\n                    filledShape = true\n                    //path.ellipse(startPoint.x, startPoint.y, lineWidth / 4, lineWidth / 4, 0, 0, 2 * Math.PI)\n                    context.beginPath()\n                    context.lineWidth = 1\n                    context.arc(startPoint.x, startPoint.y, lineWidth / 2, 0, 2 * Math.PI)\n\n                }\n\n                paths.forEach(p => {\n                    if (filledShape) {\n                        context.fill()\n                        context.lineWidth = p.lineWidth\n                    } else {\n                        context.lineWidth = p.lineWidth\n                        context.stroke(p)\n                    }\n\n\n                })\n                drawing.points = points\n            })\n            break\n        case DrawingMode.DRAW_SQUARE:\n            await drawShape(({ context, startPoint, dx, dy }) => {\n                fillShape\n                    ? context.fillRect(startPoint.x, startPoint.y, dx, dy)\n                    : context.strokeRect(startPoint.x, startPoint.y, dx, dy)\n                drawing.dx = dx\n                drawing.dy = dy\n            })\n            break\n        case DrawingMode.DRAW_CIRCLE:\n            await drawShape(({ context, startPoint, dx, dy }) => {\n                const rx = dx / 2\n                const ry = dy / 2\n                context.beginPath()\n                context.ellipse(startPoint.x + rx, startPoint.y + ry, Math.abs(rx), Math.abs(ry), 0, 0, 2 * Math.PI)\n                if (fillShape)\n                    context.fill()\n                context.stroke()\n                drawing.dx = dx\n                drawing.dy = dy\n            })\n            break\n        case DrawingMode.DRAW_TRIANGLE:\n            await drawShape(({ context, startPoint, endPoint, dx, dy }) => {\n                context.beginPath()\n                context.moveTo(startPoint.x + dx / 2, startPoint.y)\n                context.lineTo(startPoint.x, endPoint.y)\n                context.lineTo(endPoint.x, endPoint.y)\n                if (fillShape)\n                    context.fill()\n                context.stroke()\n                drawing.dx = dx\n                drawing.dy = dy\n            })\n            break\n        case DrawingMode.DRAW_LINE:\n            await drawShape(({ context, startPoint, endPoint, dx, dy }) => {\n                context.beginPath()\n                context.moveTo(startPoint.x, startPoint.y)\n                context.lineTo(endPoint.x, endPoint.y)\n                context.stroke()\n                drawing.dx = dx\n                drawing.dy = dy\n            })\n            break\n        case DrawingMode.FILL: {\n            const imgData = layerContext.getImageData(0, 0, layerCanvas.width, layerCanvas.height)\n            const floodFill = new FloodFill(imgData)\n            floodFill.fill(layerContext.color, startPoint.x, startPoint.y, 0)\n            layerContext.putImageData(floodFill.imageData, 0, 0)\n\n            break\n        }\n        case DrawingMode.SELECT: {\n            const c = workingContext.color\n            workingContext.strokeStyle = '#000000'\n            workingContext.setLineDash([5, 15])\n            await drawShape(({ context, startPoint, dx, dy }) => {\n                workingContext.strokeRect(startPoint.x, startPoint.y, dx, dy)\n                drawing.dx = dx\n                drawing.dy = dy\n            })\n\n            workingContext.setLineDash([])\n            workingContext.strokeStyle = c\n\n\n\n            break\n        }\n        default:\n            break\n    }\n\n    return drawing\n}\n\nconst CanvasContainer = styled.div`\n        position: relative;\n        width: 100%;\n        height: 100%;\n    `\n\nconst getImageData = canvas => canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height)\n\nexport default function Canvas(props) {\n    const [undoBufferInternal, setUndoBufferInternal] = React.useState([])\n    const [activeBufferIdxInternal, setActiveBufferIdxInternal] = React.useState(0)\n    const [currentBufferIdx, setCurrentBufferIdx] = React.useState(0)\n    const [copiedImage, setCopiedImage] = React.useState(undefined)\n    const workingCanvasRef = React.useRef()\n    const activeLayerCanvasRef = React.useRef()\n\n    const { color, lineWidth, mode, fillShape, onDraw, replayList, staticImage, requestClear, setRequestClear } = props\n    const { selected, setSelected, requestCopy, setRequestCopy, requestPaste, setRequestPaste, requestDelete, setRequestDelete } = props\n\n    // optional undo related properties\n    const [undoBuffer, setUndoBuffer] = props.setUndoBuffer\n        ? [props.undoBuffer, props.setUndoBuffer]\n        : [undoBufferInternal, setUndoBufferInternal]\n\n    const [activeBufferIdx, setActiveBufferIdx] = props.setActiveBufferIdx\n        ? [props.activeBufferIdx, props.setActiveBufferIdx]\n        : [activeBufferIdxInternal, setActiveBufferIdxInternal]\n\n    const startDrawing = React.useCallback(async (event) => {\n        console.log(staticImage)\n        if (event.button !== 0 || staticImage)\n            return\n\n        if (event.cancelable)\n            event.preventDefault()\n\n        const drawing = await draw({\n            startPoint: _getPos(workingCanvasRef.current, event),\n            workingCanvas: workingCanvasRef.current,\n            layerCanvas: activeLayerCanvasRef.current,\n            mode,\n            fillShape\n        })\n\n        if (mode === DrawingMode.SELECT) {\n            console.log(drawing)\n            setSelected({\n                x: drawing.drawParams.startPoint.x,\n                y: drawing.drawParams.startPoint.y,\n                dx: drawing.dx,\n                dy: drawing.dy\n            })\n        }\n\n        // Save the current image to the undo buffer\n        console.log(undoBuffer, activeBufferIdx)\n        setUndoBuffer([...undoBuffer.slice(0, activeBufferIdx + 1), {\n            imageData: getImageData(activeLayerCanvasRef.current)\n        }])\n        setCurrentBufferIdx(currentBufferIdx + 1)\n        setActiveBufferIdx(currentBufferIdx + 1)\n\n        drawing && onDraw(drawing)\n    }, [staticImage, mode, fillShape, undoBuffer, activeBufferIdx, currentBufferIdx, onDraw])\n\n    // Init canvases (one time only)\n    useEffect(() => {\n        const handler = async () => {\n            const activeCanvas = activeLayerCanvasRef.current\n            const workingCanvas = workingCanvasRef.current\n            const setCanvas = (canvas) => {\n                canvas.width = canvas.offsetWidth\n                canvas.height = canvas.offsetHeight\n                canvas.getContext('2d').translate(0.5, 0.5)\n            }\n\n            setCanvas(workingCanvas)\n            setCanvas(activeCanvas)\n            setUndoBuffer([{\n                imageData: getImageData(activeCanvas)\n            }])\n        }\n\n        handler()\n    }, [])\n\n    // Handle copy\n    useEffect(() => {\n        if (requestCopy) {\n            if (selected) {\n                const activeCanvas = activeLayerCanvasRef.current\n                const imgData = activeCanvas.getContext('2d').getImageData(selected.x, selected.y, selected.dx, selected.dy)\n                setCopiedImage(imgData)\n                // Sadly, clipboard api seems difficult to work with\n            }\n            setRequestCopy(false)\n        }\n    }, [requestCopy, selected])\n\n    // Handle paste\n    useEffect(() => {\n        if (requestPaste) {\n            if (copiedImage) {\n                const activeCanvas = activeLayerCanvasRef.current\n                const pos = _getPos(activeCanvas, requestPaste)\n                console.log(requestPaste)\n                activeCanvas.getContext('2d').putImageData(copiedImage, pos.x - copiedImage.width / 2, pos.y - copiedImage.height / 2)\n            }\n            setRequestPaste(undefined)\n        }\n    }, [requestPaste, copiedImage])\n\n    // Handle delete\n    useEffect(() => {\n        console.log(requestDelete, selected)\n        if (requestDelete) {\n            if (selected) {\n                const activeContext = activeLayerCanvasRef.current.getContext('2d')\n                activeContext.clearRect(selected.x, selected.y, selected.dx, selected.dy)\n            }\n            setRequestDelete(false)\n        }\n    }, [requestDelete, selected])\n\n    // Load static image if provided\n    useEffect(() => {\n        const handler = async () => {\n            if (staticImage) {\n                console.log(staticImage)\n                if (staticImage === \"empty\") {\n                    clear(activeLayerCanvasRef.current)\n                } else {\n                    let img = new Image()\n                    await new Promise(r => img.onload = r, img.src = staticImage)\n                    activeLayerCanvasRef.current.getContext('2d').drawImage(img, 0, 0)\n                }\n            }\n        }\n\n        handler()\n    }, [staticImage])\n\n    // Handle clear request\n    useEffect(() => {\n        if (requestClear) {\n            clear(activeLayerCanvasRef.current)\n            setRequestClear(false)\n        }\n    }, [requestClear, activeLayerCanvasRef])\n\n    // Handles buffer changes (i.e., undo/redo)\n    useEffect(() => {\n        if (activeBufferIdx >= undoBuffer.length) {\n            // out of range; disregard this operation\n            setActiveBufferIdx(currentBufferIdx)\n        } else if (activeBufferIdx !== currentBufferIdx) {\n            activeLayerCanvasRef.current.getContext('2d').putImageData(undoBuffer[activeBufferIdx].imageData, 0, 0)\n            setCurrentBufferIdx(activeBufferIdx)\n        }\n    }, [activeBufferIdx, currentBufferIdx, undoBuffer])\n\n    // Handle replay\n    useEffect(() => {\n        const handler = async () => {\n            console.log(\"replaying!\")\n\n            const activeLayerContext = activeLayerCanvasRef.current.getContext('2d')\n            const workingContext = workingCanvasRef.current.getContext('2d')\n            clear(activeLayerCanvasRef.current)\n\n            const setContextData = (context, drawing) => {\n                context.lineWidth = drawing.lineWidth\n                context.color = drawing.color\n                context.fillStyle = drawing.color\n                context.strokeStyle = drawing.color\n            }\n\n            for (const drawing of replayList) {\n                const params = drawing.drawParams\n                setContextData(activeLayerContext, drawing)\n                setContextData(workingContext, drawing)\n                await draw({\n                    ...params,\n                    workingCanvas: workingCanvasRef.current,\n                    layerCanvas: activeLayerCanvasRef.current,\n                    fakeDrawing: drawing\n                })\n            }\n            console.log(\"done replay\")\n\n        }\n\n        if (replayList)\n            handler()\n    }, [replayList])\n\n    useEffect(() => {\n        const setCanvas = (canvas) => {\n            const context = canvas.getContext('2d')\n            context.globalCompositeOperation = mode === DrawingMode.ERASE\n                ? 'destination-out'\n                : 'source-over'\n            context.globalAlpha = 1\n            context.lineWidth = lineWidth\n            context.color = color\n            context.fillStyle = color\n            context.strokeStyle = color\n        }\n\n        setCanvas(workingCanvasRef.current)\n        setCanvas(activeLayerCanvasRef.current)\n\n    }, [color, lineWidth, workingCanvasRef, activeLayerCanvasRef, mode])\n\n    return (\n        <CanvasContainer>\n            <StyledCanvas id=\"layerCanvas\" ref={activeLayerCanvasRef} />\n            <StyledCanvas id=\"workingCanvas\" ref={workingCanvasRef} onPointerDown={startDrawing} />\n        </CanvasContainer>\n    )\n}","/home/rollie/repos/drawing-app/frontend/src/Utils.js",[],"/home/rollie/repos/drawing-app/frontend/src/GameState.js",[],"/home/rollie/repos/drawing-app/frontend/src/Components/GameSummary.js",["120","121","122"],{"ruleId":"123","replacedBy":"124"},{"ruleId":"125","replacedBy":"126"},{"ruleId":"127","severity":1,"message":"128","line":19,"column":11,"nodeType":"129","messageId":"130","endLine":19,"endColumn":19},{"ruleId":"123","replacedBy":"131"},{"ruleId":"125","replacedBy":"132"},{"ruleId":"133","severity":1,"message":"134","line":31,"column":6,"nodeType":"135","endLine":31,"endColumn":8,"suggestions":"136"},{"ruleId":"133","severity":1,"message":"137","line":44,"column":6,"nodeType":"135","endLine":44,"endColumn":29,"suggestions":"138"},{"ruleId":"127","severity":1,"message":"139","line":1,"column":17,"nodeType":"129","messageId":"130","endLine":1,"endColumn":26},{"ruleId":"140","severity":1,"message":"141","line":69,"column":64,"nodeType":"142","messageId":"143","endLine":69,"endColumn":66},{"ruleId":"133","severity":1,"message":"144","line":70,"column":8,"nodeType":"135","endLine":70,"endColumn":35,"suggestions":"145"},{"ruleId":"133","severity":1,"message":"146","line":199,"column":8,"nodeType":"135","endLine":199,"endColumn":51,"suggestions":"147"},{"ruleId":"133","severity":1,"message":"148","line":251,"column":8,"nodeType":"135","endLine":251,"endColumn":78,"suggestions":"149"},{"ruleId":"133","severity":1,"message":"150","line":45,"column":8,"nodeType":"135","endLine":45,"endColumn":37,"suggestions":"151"},{"ruleId":"127","severity":1,"message":"152","line":55,"column":10,"nodeType":"129","messageId":"130","endLine":55,"endColumn":18},{"ruleId":"127","severity":1,"message":"153","line":56,"column":12,"nodeType":"129","messageId":"130","endLine":56,"endColumn":21},{"ruleId":"154","severity":1,"message":"155","line":65,"column":9,"nodeType":"156","messageId":"157","endLine":104,"endColumn":10},{"ruleId":"127","severity":1,"message":"158","line":9,"column":7,"nodeType":"129","messageId":"130","endLine":9,"endColumn":14},{"ruleId":"133","severity":1,"message":"146","line":60,"column":8,"nodeType":"135","endLine":60,"endColumn":20,"suggestions":"159"},{"ruleId":"133","severity":1,"message":"160","line":109,"column":8,"nodeType":"135","endLine":109,"endColumn":36,"suggestions":"161"},{"ruleId":"133","severity":1,"message":"162","line":148,"column":8,"nodeType":"135","endLine":148,"endColumn":25,"suggestions":"163"},{"ruleId":"127","severity":1,"message":"164","line":164,"column":7,"nodeType":"129","messageId":"130","endLine":164,"endColumn":26},{"ruleId":"133","severity":1,"message":"148","line":221,"column":8,"nodeType":"135","endLine":221,"endColumn":31,"suggestions":"165"},{"ruleId":"133","severity":1,"message":"166","line":254,"column":8,"nodeType":"135","endLine":254,"endColumn":19,"suggestions":"167"},{"ruleId":"133","severity":1,"message":"168","line":366,"column":8,"nodeType":"135","endLine":366,"endColumn":93,"suggestions":"169"},{"ruleId":"133","severity":1,"message":"170","line":387,"column":8,"nodeType":"135","endLine":387,"endColumn":10,"suggestions":"171"},{"ruleId":"133","severity":1,"message":"172","line":400,"column":8,"nodeType":"135","endLine":400,"endColumn":31,"suggestions":"173"},{"ruleId":"133","severity":1,"message":"174","line":413,"column":8,"nodeType":"135","endLine":413,"endColumn":35,"suggestions":"175"},{"ruleId":"133","severity":1,"message":"176","line":425,"column":8,"nodeType":"135","endLine":425,"endColumn":33,"suggestions":"177"},{"ruleId":"133","severity":1,"message":"178","line":451,"column":8,"nodeType":"135","endLine":451,"endColumn":44,"suggestions":"179"},{"ruleId":"133","severity":1,"message":"180","line":462,"column":8,"nodeType":"135","endLine":462,"endColumn":55,"suggestions":"181"},{"ruleId":"127","severity":1,"message":"182","line":4,"column":8,"nodeType":"129","messageId":"130","endLine":4,"endColumn":13},{"ruleId":"183","severity":1,"message":"184","line":22,"column":13,"nodeType":"185","endLine":22,"endColumn":46},{"ruleId":"127","severity":1,"message":"186","line":42,"column":19,"nodeType":"129","messageId":"130","endLine":42,"endColumn":26},"no-native-reassign",["187"],"no-negated-in-lhs",["188"],"no-unused-vars","'atrament' is assigned a value but never used.","Identifier","unusedVar",["187"],["188"],"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'setGameState' and 'setUser'. Either include them or remove the dependency array.","ArrayExpression",["189"],"React Hook useEffect has a missing dependency: 'setGameState'. Either include it or remove the dependency array.",["190"],"'useEffect' is defined but never used.","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","React Hook React.useCallback has missing dependencies: 'props.color', 'setActiveColor', and 'setColorPalette'. Either include them or remove the dependency array.",["191"],"React Hook useEffect has a missing dependency: 'setDescription'. Either include it or remove the dependency array.",["192"],"React Hook useEffect has a missing dependency: 'setDisplayedImage'. Either include it or remove the dependency array.",["193"],"React Hook React.useEffect has a missing dependency: 'setActiveBook'. Either include it or remove the dependency array.",["194"],"'TestGame' is defined but never used.","'gameState' is assigned a value but never used.","no-unreachable","Unreachable code.","VariableDeclaration","unreachableCode","'_getPos' is assigned a value but never used.",["195"],"React Hook React.useEffect has a missing dependency: 'setActiveColor'. Either include it or remove the dependency array.",["196"],"React Hook useEffect has missing dependencies: 'setActiveBufferIdx', 'setActiveTool', 'setRequestCopy', 'setRequestDelete', and 'setRequestPaste'. Either include them or remove the dependency array.",["197"],"'RequestReplayButton' is assigned a value but never used.",["198"],"React Hook React.useCallback has a missing dependency: 'setReplayDrawings'. Either include it or remove the dependency array.",["199"],"React Hook React.useCallback has missing dependencies: 'setActiveBufferIdx', 'setSelected', and 'setUndoBuffer'. Either include them or remove the dependency array.",["200"],"React Hook useEffect has a missing dependency: 'setUndoBuffer'. Either include it or remove the dependency array.",["201"],"React Hook useEffect has a missing dependency: 'setRequestCopy'. Either include it or remove the dependency array.",["202"],"React Hook useEffect has a missing dependency: 'setRequestPaste'. Either include it or remove the dependency array.",["203"],"React Hook useEffect has a missing dependency: 'setRequestDelete'. Either include it or remove the dependency array.",["204"],"React Hook useEffect has a missing dependency: 'setRequestClear'. Either include it or remove the dependency array.",["205"],"React Hook useEffect has a missing dependency: 'setActiveBufferIdx'. Either include it or remove the dependency array.",["206"],"'Modal' is defined but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","'setOpen' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"207","fix":"208"},{"desc":"209","fix":"210"},{"desc":"211","fix":"212"},{"desc":"213","fix":"214"},{"desc":"215","fix":"216"},{"desc":"217","fix":"218"},{"desc":"219","fix":"220"},{"desc":"221","fix":"222"},{"desc":"223","fix":"224"},{"desc":"225","fix":"226"},{"desc":"227","fix":"228"},{"desc":"229","fix":"230"},{"desc":"231","fix":"232"},{"desc":"233","fix":"234"},{"desc":"235","fix":"236"},{"desc":"237","fix":"238"},{"desc":"239","fix":"240"},{"desc":"241","fix":"242"},"Update the dependencies array to be: [setGameState, setUser]",{"range":"243","text":"244"},"Update the dependencies array to be: [gameState, setGameState, subscribed]",{"range":"245","text":"246"},"Update the dependencies array to be: [setActiveColor, props.color, setColorPalette, colorPalette]",{"range":"247","text":"248"},"Update the dependencies array to be: [entry.description, gameState, label, name, setDescription]",{"range":"249","text":"250"},"Update the dependencies array to be: [entry.imageUrl, gameState, label, name, presentationState.pageNumber, setDisplayedImage]",{"range":"251","text":"252"},"Update the dependencies array to be: [activeBook, gameState, setActiveBook, user]",{"range":"253","text":"254"},"Update the dependencies array to be: [activeBook, setDescription]",{"range":"255","text":"256"},"Update the dependencies array to be: [colorPalette, pushedNumber, setActiveColor]",{"range":"257","text":"258"},"Update the dependencies array to be: [activeBufferIdx, setActiveBufferIdx, setActiveTool, setRequestCopy, setRequestDelete, setRequestPaste]",{"range":"259","text":"260"},"Update the dependencies array to be: [gameState, activeBook, setDisplayedImage]",{"range":"261","text":"262"},"Update the dependencies array to be: [gameState.books, gameState.presentationState, setReplayDrawings]",{"range":"263","text":"264"},"Update the dependencies array to be: [staticImage, mode, fillShape, undoBuffer, activeBufferIdx, setUndoBuffer, currentBufferIdx, setActiveBufferIdx, onDraw, setSelected]",{"range":"265","text":"266"},"Update the dependencies array to be: [setUndoBuffer]",{"range":"267","text":"268"},"Update the dependencies array to be: [requestCopy, selected, setRequestCopy]",{"range":"269","text":"270"},"Update the dependencies array to be: [requestPaste, copiedImage, setRequestPaste]",{"range":"271","text":"272"},"Update the dependencies array to be: [requestDelete, selected, setRequestDelete]",{"range":"273","text":"274"},"Update the dependencies array to be: [requestClear, activeLayerCanvasRef, setRequestClear]",{"range":"275","text":"276"},"Update the dependencies array to be: [activeBufferIdx, currentBufferIdx, setActiveBufferIdx, undoBuffer]",{"range":"277","text":"278"},[1017,1019],"[setGameState, setUser]",[1379,1402],"[gameState, setGameState, subscribed]",[2197,2224],"[setActiveColor, props.color, setColorPalette, colorPalette]",[5758,5801],"[entry.description, gameState, label, name, setDescription]",[7536,7606],"[entry.imageUrl, gameState, label, name, presentationState.pageNumber, setDisplayedImage]",[1382,1411],"[activeBook, gameState, setActiveBook, user]",[1602,1614],"[activeBook, setDescription]",[3179,3207],"[colorPalette, pushedNumber, setActiveColor]",[4577,4594],"[activeBufferIdx, setActiveBufferIdx, setActiveTool, setRequestCopy, setRequestDelete, setRequestPaste]",[7046,7069],"[gameState, activeBook, setDisplayedImage]",[8240,8251],"[gameState.books, gameState.presentationState, setReplayDrawings]",[12686,12771],"[staticImage, mode, fillShape, undoBuffer, activeBufferIdx, setUndoBuffer, currentBufferIdx, setActiveBufferIdx, onDraw, setSelected]",[13421,13423],"[setUndoBuffer]",[13887,13910],"[requestCopy, selected, setRequestCopy]",[14391,14418],"[requestPaste, copiedImage, setRequestPaste]",[14807,14832],"[requestDelete, selected, setRequestDelete]",[15605,15641],"[requestClear, activeLayerCanvasRef, setRequestClear]",[16110,16157],"[activeBufferIdx, currentBufferIdx, setActiveBufferIdx, undoBuffer]"]