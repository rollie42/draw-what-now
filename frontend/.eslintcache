[{"/mnt/c/Users/Rollie/Documents/Repos/drawing-app/web-client/src/index.js":"1","/mnt/c/Users/Rollie/Documents/Repos/drawing-app/web-client/src/App.js":"2","/mnt/c/Users/Rollie/Documents/Repos/drawing-app/web-client/src/reportWebVitals.js":"3","/home/rollie/repos/drawing-app/frontend/src/index.js":"4","/home/rollie/repos/drawing-app/frontend/src/App.js":"5","/home/rollie/repos/drawing-app/frontend/src/reportWebVitals.js":"6","/home/rollie/repos/drawing-app/frontend/src/GameApi.js":"7","/home/rollie/repos/drawing-app/frontend/src/Context.js":"8","/home/rollie/repos/drawing-app/frontend/src/Components/MainContainer.js":"9","/home/rollie/repos/drawing-app/frontend/src/Components/DrawingControls.js":"10","/home/rollie/repos/drawing-app/frontend/src/Components/GameStateDetails.js":"11","/home/rollie/repos/drawing-app/frontend/src/Components/TopBar.js":"12","/home/rollie/repos/drawing-app/frontend/src/Components/CanvasArea.js":"13","/home/rollie/repos/drawing-app/frontend/src/Components/GameDialogs.js":"14","/home/rollie/repos/drawing-app/frontend/src/Controls.js":"15","/home/rollie/repos/drawing-app/frontend/src/Components/Canvas.js":"16","/home/rollie/repos/drawing-app/frontend/src/Utils.js":"17","/home/rollie/repos/drawing-app/frontend/src/GameState.js":"18","/home/rollie/repos/drawing-app/frontend/src/Components/GameSummary.js":"19","/home/rollie/repos/drawing-app/frontend/src/History.js":"20","/home/rollie/repos/drawing-app/frontend/src/Components/CanvasProps.js":"21","/home/rollie/repos/drawing-app/frontend/src/Components/ActionHistory.js":"22","/home/rollie/repos/drawing-app/frontend/src/Components/Drawing.js":"23","/home/rollie/repos/drawing-app/frontend/src/Components/LayerBox.js":"24","/home/rollie/repos/drawing-app/frontend/src/Components/RightSide.js":"25","/home/rollie/repos/drawing-app/frontend/src/DrawingContext.js":"26","/home/rollie/repos/drawing-app/frontend/src/Components/Turorial.js":"27"},{"size":500,"mtime":1609688572108,"results":"28","hashOfConfig":"29"},{"size":1016,"mtime":1609689164612,"results":"30","hashOfConfig":"29"},{"size":362,"mtime":1609682238588,"results":"31","hashOfConfig":"29"},{"size":542,"mtime":1617370598450,"results":"32","hashOfConfig":"33"},{"size":3814,"mtime":1620809959210,"results":"34","hashOfConfig":"33"},{"size":362,"mtime":1609690002410,"results":"35","hashOfConfig":"33"},{"size":2276,"mtime":1620547617400,"results":"36","hashOfConfig":"33"},{"size":6259,"mtime":1620675297700,"results":"37","hashOfConfig":"33"},{"size":549,"mtime":1619648681300,"results":"38","hashOfConfig":"33"},{"size":9835,"mtime":1620550751750,"results":"39","hashOfConfig":"33"},{"size":6387,"mtime":1620210484620,"results":"40","hashOfConfig":"33"},{"size":4809,"mtime":1620801164900,"results":"41","hashOfConfig":"33"},{"size":8919,"mtime":1620802304400,"results":"42","hashOfConfig":"33"},{"size":4636,"mtime":1620799829230,"results":"43","hashOfConfig":"33"},{"size":670,"mtime":1619649265920,"results":"44","hashOfConfig":"33"},{"size":20581,"mtime":1620732354820,"results":"45","hashOfConfig":"33"},{"size":1187,"mtime":1617636492850,"results":"46","hashOfConfig":"33"},{"size":776,"mtime":1620210294730,"results":"47","hashOfConfig":"33"},{"size":2000,"mtime":1620558424530,"results":"48","hashOfConfig":"33"},{"size":4960,"mtime":1620545032470,"results":"49","hashOfConfig":"33"},{"size":1012,"mtime":1620732322780,"results":"50","hashOfConfig":"33"},{"size":507,"mtime":1618731667600,"results":"51","hashOfConfig":"33"},{"size":9646,"mtime":1620678164810,"results":"52","hashOfConfig":"33"},{"size":11247,"mtime":1620561280540,"results":"53","hashOfConfig":"33"},{"size":6473,"mtime":1620698883650,"results":"54","hashOfConfig":"33"},{"size":122,"mtime":1620387821880,"results":"55","hashOfConfig":"33"},{"size":1171,"mtime":1620801391480,"results":"56","hashOfConfig":"33"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"59"},"l6gboe",{"filePath":"60","messages":"61","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"59"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},"o10i7d",{"filePath":"67","messages":"68","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"69"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76","usedDeprecatedRules":"66"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"79","usedDeprecatedRules":"66"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"82","usedDeprecatedRules":"66"},{"filePath":"83","messages":"84","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"85","messages":"86","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"87","usedDeprecatedRules":"66"},{"filePath":"88","messages":"89","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"90","usedDeprecatedRules":"66"},{"filePath":"91","messages":"92","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"93","usedDeprecatedRules":"66"},{"filePath":"94","messages":"95","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"96","usedDeprecatedRules":"66"},{"filePath":"97","messages":"98","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"99","usedDeprecatedRules":"66"},{"filePath":"100","messages":"101","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"102","usedDeprecatedRules":"66"},{"filePath":"103","messages":"104","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"105","messages":"106","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"107","usedDeprecatedRules":"66"},{"filePath":"108","messages":"109","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"110","usedDeprecatedRules":"66"},{"filePath":"111","messages":"112","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"113","messages":"114","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"115","messages":"116","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"117","usedDeprecatedRules":"66"},{"filePath":"118","messages":"119","errorCount":0,"warningCount":19,"fixableErrorCount":0,"fixableWarningCount":0,"source":"120","usedDeprecatedRules":"66"},{"filePath":"121","messages":"122","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"123","usedDeprecatedRules":"66"},{"filePath":"124","messages":"125","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"126","messages":"127","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"128","usedDeprecatedRules":"66"},"/mnt/c/Users/Rollie/Documents/Repos/drawing-app/web-client/src/index.js",[],["129","130"],"/mnt/c/Users/Rollie/Documents/Repos/drawing-app/web-client/src/App.js",["131"],"/mnt/c/Users/Rollie/Documents/Repos/drawing-app/web-client/src/reportWebVitals.js",[],"/home/rollie/repos/drawing-app/frontend/src/index.js",[],["132","133"],"/home/rollie/repos/drawing-app/frontend/src/App.js",["134","135","136","137","138"],"import './App.css';\nimport React, { useEffect } from 'react'\nimport * as GameApi from './GameApi'\nimport * as Context from './Context'\nimport styled from 'styled-components'\nimport { createGlobalStyle } from 'styled-components'\nimport MainContainer from './Components/MainContainer'\nimport TopBar from './Components/TopBar'\nimport Cookies from 'js-cookie'\nimport { GameSummary } from './Components/GameSummary'\nimport {usePrevState} from './Utils'\nimport BookReadyAudio from './sounds/task_received.mp3'\n\nfunction GameSubscriber() {\n  const [gameState, setGameState] = React.useContext(Context.GameStateContext)\n  const [, setUser] = React.useContext(Context.UserContext)\n  const [subscribed, setSubscribed] = React.useState(false)\n\n  // On first load, if we have a cookie, we can try to rejoin\n  useEffect(() => {\n    const handler = async () => {\n      const gs = Cookies.getJSON('gameState')\n      const u = Cookies.getJSON('user')\n      if (u && gs) {\n        console.log(undefined)\n        setUser(u)\n        setGameState(gs)\n      }\n    }\n    handler()\n  }, [])\n\n  // Handle subscribing if we are able to\n  useEffect(() => {\n    if (!subscribed && gameState?.id) {\n      console.log(\"subscribing\")\n      setSubscribed(true)\n      GameApi.Subscribe(gameState.id, (message) => {\n        console.log(message.data)\n        const newGameState = JSON.parse(message.data)\n        console.log(newGameState)\n        setGameState(newGameState)\n      })\n    }\n  }, [gameState, subscribed])\n\n  return (<div></div>)\n}\nconst Container = styled.div`\n    display: flex;\n    flex-flow: column;\n    height: 100vh;\n    background-color: #FFE895;\n`\n\nconst AppStyle = createGlobalStyle`\n  *{\n    @import url('https://fonts.googleapis.com/css2?family=Indie+Flower&display=swap');    \n    font-family: 'Indie Flower', cursive;\n  \n  }\n`\n\nfunction GameAudio() {\n  const [gameState] = React.useContext(Context.GameStateContext)\n  const [activeBook] = React.useContext(Context.ActiveBookContext)\n  const prevGameState = usePrevState(gameState)\n  const prevActiveBook = usePrevState(activeBook)\n\n  // If the user was waiting, let them know they have a task\n  if (activeBook && !prevActiveBook) {\n    const a = new Audio(BookReadyAudio)\n    a.volume = .2\n    a.play()\n  }\n\n  return (\n    <></>\n  )  \n}\n\nfunction useActiveBook() {\n\n}\n\nfunction ActiveBook() {\n  const [gameState] = React.useContext(Context.GameStateContext)\n  var [activeBook, setActiveBook] = React.useContext(Context.ActiveBookContext)\n  const [user] = React.useContext(Context.UserContext)\n  React.useEffect(() => {\n    if (!gameState) return\n\n    const availableBooks = gameState\n      .books\n      .filter(book => book.currentActor()?.name === user.name)\n      .sort((a,b) => b.entries.length - a.entries.length)\n    \n    if (!availableBooks.some(b => b.creator.name === activeBook?.creator?.name)) {\n      // TODO: The currently active book isn't active - presumably retracted \n      // (notify box)\n      // setNotificationMessage(\"This page has been retracted\")\n      activeBook = undefined\n    }\n\n    setActiveBook(activeBook ?? availableBooks[0])\n  }, [activeBook, gameState, user])\n\n  return (\n    <></>\n  )\n}\n\nexport var mousePosition = undefined\n\nfunction PageContent() {\n  const [gameState] = React.useContext(Context.GameStateContext)\n\n  document.addEventListener('pointermove', (e) => {\n    mousePosition = e\n  })\n\n  return (\n    <>\n      <Container>\n        <TopBar />\n        <MainContainer />\n\n        <GameSubscriber />\n        <GameAudio />\n        <ActiveBook />\n        {gameState?.isGameOver() && <GameSummary />}\n      </Container>\n    </>\n  )\n}\n\nexport default function App() {\n  return (\n    <div className=\"App\">\n      <AppStyle />\n      <Context.AppContextProvider>\n        <PageContent />\n      </Context.AppContextProvider>\n    </div>\n  )\n}\n","/home/rollie/repos/drawing-app/frontend/src/reportWebVitals.js",[],"/home/rollie/repos/drawing-app/frontend/src/GameApi.js",[],"/home/rollie/repos/drawing-app/frontend/src/Context.js",["139"],"import React, { useEffect } from 'react';\nimport { DrawingMode, Shapes } from './Components/Canvas'\nimport { GameState } from './GameState'\nimport Cookies from 'js-cookie'\nimport { v4 as uuidv4 } from 'uuid'\n\nexport const UserContext = React.createContext()\nexport const ActiveBookContext = React.createContext()\nconst defaultColor = \"rgba(255, 0, 0, 1)\"\nexport const ActiveColorContext = React.createContext(defaultColor)\nexport const ColorPalette = React.createContext([])\nexport const LineWidthContext = React.createContext(1)\nexport const TasksContext = React.createContext([])\nexport const GameStateContext = React.createContext(null)\nexport const ActiveToolContext = React.createContext(DrawingMode.DRAW)\nexport const ActiveShapeContext = React.createContext(Shapes.SQUARE)\nexport const FillShapeContext = React.createContext(true)\nexport const DescriptionContext = React.createContext(\"\")\nexport const StaticImageContext = React.createContext(\"\")\nexport const ReplayDrawingsContext = React.createContext([])\nexport const RequestClearContext = React.createContext(false)\nconst defaultLayer = {\n    name: 'Background',\n    id: uuidv4(),\n    active: true,\n    visible: true\n}\nexport const LayerContext = React.createContext([defaultLayer])\nexport const ActionHistoryContext = React.createContext([])\nexport const RecentSubmissionContext = React.createContext(undefined)\n\nexport function AppContextProvider(props) {\n    const [user, setUser] = React.useState(null)\n    const setUserWrapper = (u) => {\n\n        if (u)\n            Cookies.set(\"user\", u)\n        else\n            Cookies.remove(\"user\")\n        setUser(u)\n    }\n    const [activeBook, setActiveBook] = React.useState(null)\n    const [activeColor, setActiveColor] = React.useState(defaultColor)\n    const [colorPalette, setColorPalette] = React.useState([])\n    const [lineWidth, setLineWidth] = React.useState(1)\n    const [tasks, setTasks] = React.useState([])\n    const [gameState, setGameState] = React.useState(null)\n    const setGameStateWrapper = (gs) => {\n        console.log(gs)\n        if (gs && gs.type !== \"error\") {\n            console.log(gs)\n            Cookies.set(\"gameState\", gs)            \n            setGameState(new GameState(gs))\n        } else {\n            Cookies.remove(\"gameState\")\n            setGameState(undefined)\n        }\n    }\n    const [activeTool, setActiveTool] = React.useState(DrawingMode.DRAW)\n    const [activeShape, setActiveShape] = React.useState(Shapes.SQUARE)\n    const [fillShape, setFillShape] = React.useState(true)\n    const [description, setDescription] = React.useState(\"\")\n    const [staticImage, setStaticImage] = React.useState(\"\")\n    const [replayDrawings, setReplayDrawings] = React.useState([])\n    const [requestClear, setRequestClear] = React.useState(false)\n    const [layers, setLayers] = React.useState([defaultLayer])\n    const [actionHistory, setActionHistory] = React.useState([])\n    const pushAction = (action) => {\n        setActionHistory(actions => {\n            return [...actions.filter(a => a.active), action]\n        })\n    }\n    const [recentSubmission, setRecentSubmission] = React.useState(undefined)\n    return (\n        <UserContext.Provider value={[user, setUserWrapper]}>\n            <ActiveBookContext.Provider value={[activeBook, setActiveBook]}>\n                <ActiveColorContext.Provider value={[activeColor, setActiveColor]}>\n                    <ColorPalette.Provider value={[colorPalette, setColorPalette]}>\n                        <LineWidthContext.Provider value={[lineWidth, setLineWidth]}>\n                            <TasksContext.Provider value={[tasks, setTasks]}>\n                                <GameStateContext.Provider value={[gameState, setGameStateWrapper]}>\n                                    <ActiveToolContext.Provider value={[activeTool, setActiveTool]}>\n                                        <ActiveShapeContext.Provider value={[activeShape, setActiveShape]}>\n                                            <FillShapeContext.Provider value={[fillShape, setFillShape]}>\n                                                <DescriptionContext.Provider value={[description, setDescription]}>\n                                                    <StaticImageContext.Provider value={[staticImage, setStaticImage]}>\n                                                        <ReplayDrawingsContext.Provider value={[replayDrawings, setReplayDrawings]}>\n                                                            <RequestClearContext.Provider value={[requestClear, setRequestClear]}>\n                                                                <LayerContext.Provider value={[layers, setLayers]}>\n                                                                    <ActionHistoryContext.Provider value={[actionHistory, setActionHistory, pushAction]}>\n                                                                        <RecentSubmissionContext.Provider value={[recentSubmission, setRecentSubmission]}>\n                                                                            {props.children}\n                                                                        </RecentSubmissionContext.Provider>\n                                                                    </ActionHistoryContext.Provider>\n                                                                </LayerContext.Provider>\n                                                            </RequestClearContext.Provider>\n                                                        </ReplayDrawingsContext.Provider>\n                                                    </StaticImageContext.Provider>\n                                                </DescriptionContext.Provider>\n                                            </FillShapeContext.Provider>\n                                        </ActiveShapeContext.Provider>\n                                    </ActiveToolContext.Provider>\n                                </GameStateContext.Provider>\n                            </TasksContext.Provider>\n                        </LineWidthContext.Provider>\n                    </ColorPalette.Provider>\n                </ActiveColorContext.Provider>\n            </ActiveBookContext.Provider>\n        </UserContext.Provider>\n    )\n}\n\n","/home/rollie/repos/drawing-app/frontend/src/Components/MainContainer.js",["140"],"import React from 'react'\nimport styled from 'styled-components'\nimport DrawingControls from './DrawingControls'\nimport RightSide from './RightSide'\nimport GameStateDetails from './GameStateDetails'\nimport CanvasArea from './CanvasArea'\n\nconst Container = styled.div`\n    flex: 1;\n    display: flex;\n`\n\nexport default function MainContainer(props) {\n    return (\n        <Container>\n            <DrawingControls />\n            <CanvasArea />\n            <RightSide />            \n            {/* <GameStateDetails /> */}\n        </Container>\n    )\n}","/home/rollie/repos/drawing-app/frontend/src/Components/DrawingControls.js",["141","142","143","144","145"],"import React, { useEffect } from 'react'\nimport styled from 'styled-components'\nimport * as Context from '../Context'\nimport {sleep} from '../Utils'\nimport { DrawingMode, Shapes } from './Canvas'\nimport \"react-colorful/dist/index.css\"\n\nimport PaintBrushImg from '../images/paint-brush.png'\nimport ShapeToolImg from '../images/shape-tool.png'\nimport LineToolImg from '../images/line-tool.png'\nimport PaintBucketImg from '../images/paint-bucket.png'\nimport EraserImg from '../images/eraser.png'\nimport SelectRegion from '../images/select-region.png'\nimport Hand from '../images/hand.png'\nimport UndoImg from '../images/undo.png'\nimport RedoImg from '../images/redo.png'\nimport SquareImg from '../images/square.png'\nimport SquareFilledImg from '../images/square-filled.png'\nimport CircleImg from '../images/circle.png'\nimport CircleFilledImg from '../images/circle-filled.png'\nimport TriangleImg from '../images/triangle.png'\nimport TriangleFilledImg from '../images/triangle-filled.png'\nimport { withStyles } from '@material-ui/core';\n\nconst Container = styled.div`    \n    display: flex;\n    flex-direction: column;\n    height: 100%;\n`\n\nconst ControlPanel = styled.div`\n    text-align: left;\n    margin-top:100px;\n`\n\nconst LabelContainer = styled.div`\n    font-size: 30px;\n    display: inline-block;\n    width: 100%;\n    margin: 0px 30px 32px 0px;\n    text-align: right;\n    transform: translate(-60px, 0px);\n    opacity: 0;\n    padding: 30px 0px;    \n\n    &.showing {\n        transition: transform 0.75s ease;\n        transform: translate(0px, 0px);\n        opacity: 1;\n    }\n\n    &.hiding {\n        transition: opacity 0.5s;\n        opacity: 0;        \n        transform: translate(0px, 0px);\n    }\n`\n\nfunction DescriptionLabel() {\n    const [gameState] = React.useContext(Context.GameStateContext)\n    const [, setDescription] = React.useContext(Context.DescriptionContext)\n    const [label, setLabel] = React.useState(\"\")\n    const [className, setClassName] = React.useState(\"\")\n\n    var name = \"\"\n    if (gameState) {\n        const presentationState = gameState.presentationState\n        const book = gameState.books?.find(b => b.creator.name === presentationState.bookOwner)\n        var entry = book?.entries[presentationState.pageNumber]\n        if (entry?.imageUrl)\n            entry = book.entries[presentationState.pageNumber - 1]\n\n        name = entry?.author?.name\n    }\n\n    useEffect(() => {\n        console.log(gameState)\n        const handler = async () => {\n            const newLabel = `${name} wrote:`\n            if (newLabel !== label) {\n                // Fade old text out\n                setClassName('hiding')\n                await sleep(500)          \n                setClassName('')\n                // Update text, slide in\n                setLabel(newLabel)\n                await sleep(200)\n                setClassName('showing')\n\n                await sleep(800)\n                setDescription(entry.description)\n            }\n        }\n\n        handler()\n    }, [entry.description, gameState, label, name])\n\n    return (\n        <LabelContainer className={className}>\n            <span>{label}</span>\n        </LabelContainer>\n    )\n}\n\nfunction ImageLabel() {\n    const [gameState] = React.useContext(Context.GameStateContext)\n    const [, setStaticImage] = React.useContext(Context.StaticImageContext)\n    const [label, setLabel] = React.useState(\"\")\n    const [className, setClassName] = React.useState(\"\")\n    \n    const presentationState = gameState.presentationState\n    // const book = gameState.books.find(b => b.creator.name === presentationState.bookOwner)\n\n    var name = \"\"\n    if (gameState) {\n        const presentationState = gameState.presentationState\n        const book = gameState.books.find(b => b.creator.name === presentationState.bookOwner)\n        var entry = book.entries[presentationState.pageNumber]\n        console.log(presentationState, book.entries)\n        if (entry.description && presentationState.pageNumber > 0)\n            entry = book.entries[presentationState.pageNumber - 1]\n\n        name = entry?.author?.name\n    }\n\n    useEffect(() => {\n        const handler = async () => {\n            const newLabel = `${name} drew:`\n            \n            if (presentationState.pageNumber === 0) {\n                setStaticImage(entry.imageUrl)\n                setLabel(\"\")\n            } else if (newLabel !== label) {\n                // Fade old text out\n                setClassName('hiding')\n                await sleep(500)          \n                setClassName('')\n                // Update text, slide in\n                setLabel(newLabel)\n                await sleep(200)\n                setClassName('showing')\n\n                await sleep(800)\n                setStaticImage(entry.imageUrl)\n            }\n        }\n\n        handler()\n    }, [entry.imageUrl, gameState, label, name, presentationState.pageNumber])\n\n    return (\n        <LabelContainer className={className}>\n            {presentationState.pageNumber > 0 && <span>{label}</span>}\n        </LabelContainer>\n    )\n}\n\nconst BookTitleContainer = styled.div`    \n    font-family: 'Shadows Into Light', cursive;\n    font-size: 100px;\n    position: fixed;\n    color: #7F0037;\n    transform: translate(130px, -15px) rotate(-18deg);    \n    z-index: 3;\n`\n\nfunction BookTitle() {\n    const [gameState] = React.useContext(Context.GameStateContext)\n    const presentationState = gameState.presentationState\n    return (\n        <BookTitleContainer>{presentationState.bookOwner}'s Book</BookTitleContainer>\n    )\n}\n\nconst DeadSpace = styled.div`\n    flex: 1;\n`\n\nconst DeadSpaceTop = styled.div`\n    flex: 1;\n`\n\n\nconst ToggleButtonImage = styled.img`\n    width: 38px;\n    height: 38px;\n`    \nconst ToolButtonContainer = styled.div`\n    position: relative;\n`\nconst ToggleButton = styled.button`\n    \n    background: ${props => props.selected ? 'rgba(0,0,0,0.12)' : 'none'};\n    border: 1px solid rgba(0,0,0,0.12);\n    padding: 11px;\n    cursor: pointer;\n\n    :hover {\n        background-color: ${props => props.selected ? 'rgba(0,0,0,0.15)' : 'rgba(0,0,0,0.05)'};\n    }\n    \n`\n\nfunction ToolButton({img, mode, children}) {\n    const [activeTool, setActiveTool] = React.useContext(Context.ActiveToolContext);\n    const clickHandler = () => {\n        setActiveTool(mode)\n    }\n\n    return (\n        <ToolButtonContainer>\n            <ToggleButton onClick={clickHandler} selected={activeTool === mode}>\n                <ToggleButtonImage src={img}/>\n            </ToggleButton>\n            {children}\n        </ToolButtonContainer>\n    )\n}\n\nconst ToolSelectorContainer = styled.div`\n`\n\nfunction ToolSelector() {\n    return (\n        <ToolSelectorContainer>\n            <ToolButton mode={DrawingMode.DRAW} img={PaintBrushImg} />\n            <ToolButton mode={'draw-shape'} img={ShapeToolImg}>\n                <ShapeSelector />\n            </ToolButton>\n            <ToolButton mode={DrawingMode.DRAW_LINE} img={LineToolImg} />\n            <ToolButton mode={DrawingMode.FILL} img={PaintBucketImg} />\n            <ToolButton mode={DrawingMode.ERASE} img={EraserImg} />\n            <ToolButton mode={DrawingMode.SELECT} img={SelectRegion} />\n            <ToolButton mode={DrawingMode.MOVE} img={Hand} />\n        </ToolSelectorContainer>\n    )\n}\n\nconst ShapeOptionsContainer = styled.div`\n    z-index: 2;\n    position: absolute;\n    background-color: #FFE895;\n    top: 0px;\n    left:60px;\n    overflow: hidden;\n    max-width: 0px;\n    transition: max-width .1s ease-in-out;\n\n    ${ToolButtonContainer}:hover & {\n        max-width: 200px;\n        transition: max-width .2s ease-in-out;\n    }\n`\n\nfunction ShapeButton({img, shape, filled}) {    \n    const [activeShape, setActiveShape] = React.useContext(Context.ActiveShapeContext)\n    const [fillShape, setFillShape] = React.useContext(Context.FillShapeContext)\n    const [, setActiveTool] = React.useContext(Context.ActiveToolContext);\n    \n    const clickHandler = () => {\n        setActiveShape(shape)\n        setFillShape(filled)\n        setActiveTool(DrawingMode.DRAW_SHAPE)\n    }\n    return (\n        <ToggleButton onClick={clickHandler} selected={activeShape === shape && fillShape === filled}>\n            <ToggleButtonImage src={img}/>\n        </ToggleButton>\n    )\n}\n\nconst ShapeRow = styled.div`\n    white-space: nowrap;\n`\n\nfunction ShapeSelector() {\n    const [activeTool] = React.useContext(Context.ActiveToolContext)\n    return (        \n        <ShapeOptionsContainer show={activeTool === DrawingMode.DRAW_SHAPE}>\n            <ShapeRow>\n                <ShapeButton img={SquareFilledImg} shape={Shapes.SQUARE} filled={true} />\n                <ShapeButton img={CircleFilledImg} shape={Shapes.CIRCLE} filled={true} />\n                <ShapeButton img={TriangleFilledImg} shape={Shapes.TRIANGLE} filled={true} />\n            </ShapeRow>\n            <ShapeRow>\n                <ShapeButton img={SquareImg} shape={Shapes.SQUARE} filled={false} />\n                <ShapeButton img={CircleImg} shape={Shapes.CIRCLE} filled={false} />\n                <ShapeButton img={TriangleImg} shape={Shapes.TRIANGLE} filled={false} />\n            </ShapeRow>\n        </ShapeOptionsContainer>\n    )\n}\n\n\nexport default function DrawingControls() {\n    const [gameState] = React.useContext(Context.GameStateContext)\n    const presentingSummary = [\"PresentingSummary\"].includes(gameState?.gameStatus)\n\n    return (\n        <Container>\n            {![\"PresentingSummary\", \"Completed\"].includes(gameState?.gameStatus) && <ControlPanel>\n                <ToolSelector />\n            </ControlPanel>}\n            {presentingSummary && <BookTitle />}\n            {presentingSummary && <DeadSpaceTop />}\n            {presentingSummary && <ImageLabel />}\n            {presentingSummary && <DeadSpace />}\n            {presentingSummary && <DescriptionLabel />}\n        </Container>\n    )\n}","/home/rollie/repos/drawing-app/frontend/src/Components/GameStateDetails.js",[],"/home/rollie/repos/drawing-app/frontend/src/Components/TopBar.js",["146","147","148"],"import React from 'react'\nimport styled from 'styled-components'\nimport * as Context from '../Context'\nimport * as GameApi from '../GameApi'\nimport { JoinGameDialog, CreateGameDialog } from './GameDialogs'\nimport {TutorialDialog} from './Turorial'\nimport { ImageButton, Button } from '../Controls'\nimport CreateGameImage from '../images/create-game.png'\nimport JoinGameImage from '../images/join-game.png'\nimport ExitGameImage from '../images/exit.png'\nimport HelpImage from '../images/help.png'\nimport LogoImage from '../images/logo.png'\nimport PupImage from '../images/pup.png'\nimport PupSpeechBehindImage from '../images/pup-speech-behind.png'\nimport PupSpeechHurryImage from '../images/pup-speech-hurry.png'\n\nconst TopControlContainer = styled.div`\n    display: flex;\n    align-items: center;\n    color: #dddddd;\n    font-size: 22px;\n    margin: 0px 10px;\n`\n\nconst TopBarImageButton = (props) => (<ImageButton {...props} height=\"70px\" />)\n\nconst groupBy = (list, keyGetter) =>\n        list.reduce(function (r, a) {\n            r[keyGetter(a)] = r[keyGetter(a)] || [];\n            r[keyGetter(a)].push(a);\n            return r;\n        }, Object.create(null));\n        \nfunction JoinGame() {\n    const [open, setOpen] = React.useState(false)\n\n    return (\n        <TopControlContainer>\n            <TopBarImageButton onClick={() => setOpen(true)} image={JoinGameImage} ></TopBarImageButton>\n            <JoinGameDialog open={open} setOpen={setOpen} />\n        </TopControlContainer>\n    )\n}\n\nfunction CreateGame() {\n    const [open, setOpen] = React.useState(false)\n\n    return (\n        <TopControlContainer>\n            <TopBarImageButton onClick={() => setOpen(true)} image={CreateGameImage} ></TopBarImageButton>\n            <CreateGameDialog open={open} setOpen={setOpen} />\n        </TopControlContainer>\n    )\n}\n\nfunction ExitGame() {\n    const [, setGameState] = React.useContext(Context.GameStateContext)\n    const [, setUser] = React.useContext(Context.UserContext)\n    const clickHandler = () => {\n        setGameState(undefined)\n        setUser(undefined)\n    }\n\n    return (\n        <TopControlContainer>\n            <TopBarImageButton onClick={clickHandler} image={ExitGameImage} ></TopBarImageButton>\n        </TopControlContainer>\n    )\n}\n\nfunction Help() {\n    const [open, setOpen] = React.useState(false)\n    const clickHandler = () => {\n        setOpen(true)\n    }\n\n    return (\n        <TopControlContainer>\n            <TopBarImageButton onClick={clickHandler} image={HelpImage} ></TopBarImageButton>\n            <TutorialDialog open={open} setOpen={setOpen} />\n        </TopControlContainer>\n    )\n}\n\nconst TopBarContainer = styled.div`\n    width: 100%;\n    height: 75px;\n    background-color: #FFBF76;\n    display: flex;\n    justify-content: flex-end;\n    margin-bottom: 12px;\n    padding-left: 8px;\n`\n\nconst DeadSpace = styled.div`\n    flex: 1;\n`\n\nconst SVG = styled.svg`\n    display: inline-flex;\n    width: 70px;\n    height: 70px;\n    margin: 0px 2px;\n    padding: 3px;\n    ${props => props.selected && `background-color: #222222;`}\n`\n\nfunction Logo() {\n    return (\n        <TopBarImageButton image={LogoImage} ></TopBarImageButton>\n    )\n}\n\nconst PupSpeechContainer = styled.img`\n    width: 130px;\n    height: 80px;\n    position: absolute;\n    left:20px;\n    top: 5px;\n`\n\nconst PupContainer = styled.div`\n    position: relative;\n`\nfunction Pup() {\n    const [gameState] = React.useContext(Context.GameStateContext)\n    const [user] = React.useContext(Context.UserContext)\n\n    var img = \"\"\n    console.log(gameState)\n    const entries = gameState?.books?.map(book => book.entries).flat().filter(entry => entry.imageUrl)\n    if (entries?.length) {\n        const groups = groupBy(entries, entry => entry.author.name)\n        const imagesDone = Object.values(groups).map(arr => arr.length).sort()\n        const median = imagesDone[Math.floor(imagesDone.length / 2)]\n        const userCompleted = groups[user.name]?.length || 0\n        img = userCompleted >= median\n            ? \"\"\n            : userCompleted >= median - 1\n                ? PupSpeechBehindImage\n                : PupSpeechHurryImage\n    }\n    return (\n        <PupContainer>\n            <TopBarImageButton image={PupImage} ></TopBarImageButton>\n            {img && <PupSpeechContainer src={img}/>}\n        </PupContainer>\n        )\n}\n\nexport default function TopBar() {\n    const [gameState] = React.useContext(Context.GameStateContext)\n    return (\n        <TopBarContainer>\n            <Pup />\n            <DeadSpace />\n            <Logo />\n            <DeadSpace />\n            {!gameState &&\n                <>\n                    <JoinGame />\n                    <CreateGame />\n                </>\n            }\n            {gameState && <ExitGame />}\n            <Help />\n        </TopBarContainer>\n    )\n}","/home/rollie/repos/drawing-app/frontend/src/Components/CanvasArea.js",["149","150","151","152","153","154","155","156"],"import React, { useEffect } from 'react'\nimport Canvas, { DrawingMode } from './Canvas'\nimport * as Context from '../Context'\nimport styled from 'styled-components'\nimport ReplayIcon from '@material-ui/icons/Replay'\nimport { mousePosition } from '../App'\nimport {useCanvasProps} from './CanvasProps'\nimport { contextsToProps } from '../Utils'\n\nimport NotebookImage from '../images/note.png'\nimport NotebookRingsImg from '../images/note-rings.png'\n\nconst DescriptionContainer = styled.div`\n    \n    background-color: #a4e6ff66;\n    position: absolute;\n    bottom: 1vh;\n    right: 10vh;\n    left: 10vh;\n    z-index: ${props => props.inputting ? '20' : '1'};\n`\n\nfunction lastEntry(book) {\n    if (!book?.entries)\n        return undefined\n\n    return book.entries[book.entries.length - 1]\n}\n\nconst DescriptionInput = styled.input`\n    background: none;\n    width: 100%;\n    min-height: 80px;\n    font-size:40px;\n    text-align:center;\n    border: none;\n    outline: none;\n\n    &:focus {\n        &::placeholder {\n            color: transparent;\n        }\n    }\n`\n\nfunction Description() {\n    const [activeBook] = React.useContext(Context.ActiveBookContext)\n    const [description, setDescription] = React.useContext(Context.DescriptionContext)\n\n    useEffect(() => {\n        console.log(activeBook)\n        if (!activeBook?.entries || activeBook.entries.length % 2 === 0) {\n            console.log(1, lastEntry(activeBook))\n            setDescription(\"\")\n        } else {\n            console.log(2, lastEntry(activeBook))\n            setDescription(lastEntry(activeBook).description)\n        }\n    }, [activeBook])\n\n\n    var helpText = \"What is this image?\"\n    var readOnly = false\n    if (!activeBook) {\n        helpText = \"\"\n    } else if (activeBook.entries.length === 0) {\n        // Active book is empty, so it's our book - pick a phrase\n        helpText = \"Pick a phrase\"\n    } else if (activeBook.entries.length % 2 === 1) {\n        readOnly = true\n    }\n\n    const descriptionChange = (event) => {\n        if (event.cancelable)\n            event.preventDefault()\n\n        event.stopPropagation()\n        setDescription(event.target.value)\n    }\n    return (\n        <DescriptionContainer inputting={activeBook && activeBook.entries.length % 2 === 0}>\n            <DescriptionInput readOnly={readOnly} placeholder={helpText} value={description} onChange={descriptionChange} />\n        </DescriptionContainer>\n    )\n}\n\nfunction Keybinds(props) {\n    const [pushedNumber, setPushedNumber] = React.useState(undefined)\n    const [, setActiveTool] = React.useContext(Context.ActiveToolContext)\n\n    const { setActiveColor, colorPalette } = props\n    const { setRequestUndo, setRequestRedo, setRequestCopy, setRequestPaste, setRequestDelete } = props\n\n\n    // Color commands\n    React.useEffect(() => {\n        if (pushedNumber !== undefined) {\n            // convert to an index\n            var idx = pushedNumber === 0 ? 9 : pushedNumber - 1\n            if (colorPalette.length > idx) {\n                setActiveColor(colorPalette[idx])\n            }\n\n            // clear this event\n            setPushedNumber(undefined)\n        }\n    }, [colorPalette, pushedNumber])\n\n    useEffect(() => {\n        // Tool commands\n        const toolKeybinds = {\n            q: DrawingMode.DRAW,\n            w: 'draw-shape',\n            e: DrawingMode.DRAW_LINE,\n            r: DrawingMode.FILL,\n            a: DrawingMode.ERASE,\n            s: DrawingMode.SELECT,\n            d: DrawingMode.MOVE\n        }\n\n        const keydownHandler = (e) => {\n            if (e.target instanceof HTMLInputElement)\n                return\n\n            if (e.key === 'z' && e.ctrlKey) {\n                setRequestUndo(true)\n            } else if (e.key === 'y' && e.ctrlKey) {\n                setRequestRedo(true)\n            } else if (e.key === 'c' && e.ctrlKey) {\n                setRequestCopy(true)\n            } else if (e.key === 'v' && e.ctrlKey) {\n                setRequestPaste(mousePosition)\n            } else if (e.key === 'Delete') {\n                setRequestDelete(true)\n            } else if (parseInt(e.key) >= 0) {\n                setPushedNumber(Number(e.key))\n            } else if (e.key === '[') {\n                props.setLineWidth(w => w > 30 ? w - 2 : w - 1)\n            } else if (e.key === ']') {\n                props.setLineWidth(w => w > 30 ? w + 2 : w + 1)\n            } else if (e.key in toolKeybinds) {\n                setActiveTool(toolKeybinds[e.key])\n            }\n        }\n\n        window.addEventListener('keydown', keydownHandler)\n        return () => window.removeEventListener('keydown', keydownHandler)\n    }, [])\n\n    return (<></>)\n}\n\nconst ConvasBackgroundContainer = styled.div`\n`\nconst ConvasAreaContainer = styled.div`\n  position: relative;\n  flex: 0;\n  min-width: 75vw;\n  display: flex;\n  flex-flow: column;\n  margin: 0px 0px;\n  background-image: url(${NotebookImage});\n  background-size: 100% 100%;\n  background-position: center;\n  padding: 5.2vh 2.8vw 7vh 1.1vw;\n`\n\nconst NotebookRingsContainer = styled.div`\n    width: 100%;\n    height: 100%;\n    background-image: url(${NotebookRingsImg});\n    background-size: 100% 100%;\n    background-position: center;\n    position: absolute;\n    top: 0px;\n    left: 0px;\n`\n\n// padding: 10vh 2.4vw 0px 0.9vw;\nconst RequestReplayButton = styled.button`\n    position: absolute;\n    top: 0px;\n    left: 80px;\n`\n\nconst ReplayButtonStyled = styled.button`\n    width:50px;\n    height:50px;\n    position: absolute;\n    right: 90px;\n    bottom: 70px;\n`\n\nconst CanvasActiveArea = styled.div`\n    position: relative;\n    width: 100%;\n    height: 100%;\n`\n\nfunction ReplayButton(props) {\n    return (\n        <ReplayButtonStyled onClick={props.onClick}><ReplayIcon /></ReplayButtonStyled>\n    )\n}\n\nexport default function CanvasArea() {\n    const [gameState] = React.useContext(Context.GameStateContext)\n    const [activeBook] = React.useContext(Context.ActiveBookContext)\n    const [requestReplay, setRequestReplay] = React.useState(false)\n\n    const [activeColor] = React.useContext(Context.ActiveColorContext)\n\n    const contextProps = contextsToProps({\n        'activeColor': Context.ActiveColorContext,\n        'lineWidth': Context.LineWidthContext,\n        'fillShape': Context.FillShapeContext,\n        'colorPalette': Context.ColorPalette,\n        'staticImage': Context.StaticImageContext,\n        'replayDrawings': Context.ReplayDrawingsContext,\n        'requestClear': Context.RequestClearContext,\n        'layers': Context.LayerContext,\n        'actionHistory': Context.ActionHistoryContext,\n        'mode': Context.ActiveToolContext,\n        'shape': Context.ActiveShapeContext,\n    })\n    const canvasProps = useCanvasProps(contextProps)\n\n    useEffect(() => {\n        console.log(\"requestReplay\", requestReplay)\n        if (requestReplay) {\n            setRequestReplay(false)\n        }\n    }, [requestReplay])\n\n    useEffect(() => {\n        if (!gameState)\n            return\n\n        canvasProps.setStaticImage(\"\")\n        if (gameState.gameStatus === \"PresentingSummary\" && gameState.presentationState.pageNumber === 0)\n            canvasProps.setStaticImage(\"empty\")\n\n        if (activeBook && activeBook.entries.length % 2 === 0)\n            canvasProps.setStaticImage(\"empty\")\n    }, [gameState, activeBook])\n\n    const wheelHandler = (e) => {\n        const d = Math.trunc(canvasProps.lineWidth / 14) + 1\n        const w = canvasProps.lineWidth + (e.deltaY < 0 ? d : -d)\n        canvasProps.setLineWidth(Math.max(1, Math.min(w, 72)))\n    }\n\n    const onDraw = React.useCallback(() => {\n        canvasProps.setColorPalette(palette => {\n            if (!palette.includes(activeColor))\n                return ([...palette, activeColor])\n            return palette\n        })\n    }, [activeColor])\n\n    // const activelyDrawing = activeBook && activeBook.entries.length % 2 === 1\n    // const isDrawing = !gameState || gameState.gameStatus === \"NotStarted\" || activelyDrawing\n\n    const handleRequestReplay = React.useCallback(() => {\n        const ps = gameState.presentationState\n        const book = gameState.books?.find(b => b.creator.name === ps.bookOwner)\n        var entry = book?.entries[ps.pageNumber]\n        if (!entry.imageUrl)\n            entry = book.entries[ps.pageNumber - 1]\n\n        canvasProps.setReplayDrawings(JSON.parse(entry.replayDrawings))\n        setRequestReplay(true)\n    }, [gameState])\n\n\n    return (\n        <ConvasAreaContainer onWheel={wheelHandler}>\n            <Keybinds {...canvasProps} />\n            <CanvasActiveArea>\n                <Canvas\n                    onDraw={onDraw}\n                    {...canvasProps}\n\n                />                \n                {false && gameState?.isPresenting() && <ReplayButton onClick={handleRequestReplay} />}\n                <Description />                \n            </CanvasActiveArea>\n            <NotebookRingsContainer />\n        </ConvasAreaContainer>\n    )\n}","/home/rollie/repos/drawing-app/frontend/src/Components/GameDialogs.js",["157"],"import React from 'react';\nimport styled from 'styled-components'\nimport * as Context from '../Context'\nimport * as GameApi from '../GameApi'\nimport Modal from 'react-modal';\nimport { Button } from '../Controls'\n\nconst FieldContainer = styled.div`\n    justify-content: space-between;\n    padding-bottom: 8px;\n`\n\nconst Label = styled.label`\n    display: block;\n`\n\nconst Input = styled.input`\n    display: block;\n`\n\nfunction UserName(props) {\n    const { userName, setUserName } = props\n\n    return (\n        <FieldContainer>\n            <Label>Your name</Label>\n            <Input autoFocus type=\"text\" value={userName} onChange={e => setUserName(e.target.value)} />\n        </FieldContainer>\n    )\n}\n\nfunction GameName(props) {\n    const { gameName, setGameName } = props\n\n    return (\n        <FieldContainer>\n            <Label>Game name</Label>\n            <Input type=\"text\" value={gameName} onChange={e => setGameName(e.target.value)} />\n        </FieldContainer>\n    )\n}\n\n\nModal.setAppElement('#root');\n\nconst c = \"#11050310\"\nexport const DialogHeader = styled.div`\n    width: 100%;\n    background-color: #FFBF76;\n    text-align: center;\n    outline: none;\n    padding: 5px 0px;\n    color: #A4E6FF;\n    font-size: 24px;\n    text-shadow:\n    -2px   -2px ${c},\n    -2px -1.5px ${c},\n    -2px   -1px ${c},\n    -2px -0.5px ${c},\n    -2px    0px ${c},\n    -2px  0.5px ${c},\n    -2px    1px ${c},\n    -2px  1.5px ${c},\n    -2px    2px ${c},\n    -1.5px  2px ${c},\n    -1px    2px ${c},\n    -0.5px  2px ${c},\n    0px     2px ${c},\n    0.5px   2px ${c},\n    1px     2px ${c},\n    1.5px   2px ${c},\n    2px     2px ${c},\n    2px   1.5px ${c},\n    2px     1px ${c},\n    2px   0.5px ${c},\n    2px     0px ${c},\n    2px  -0.5px ${c},\n    2px    -1px ${c},\n    2px  -1.5px ${c},\n    2px    -2px ${c},\n    1.5px  -2px ${c},\n    1px    -2px ${c},\n    0.5px  -2px ${c},\n    0px    -2px ${c},\n    -0.5px -2px ${c},\n    -1px   -2px ${c},\n    -1.5px -2px ${c};\n`\n\nexport const DialogContent = styled.div`\n    padding: 12px;\n`\n\nconst DialogControl = styled.div`\n    padding: 4px;\n`\n\nexport const DialogContainer = (props) => {\n    return (<Modal className=\"modal\" overlayClassName=\"modalBackground\" {...props} />)\n}\n\nexport function JoinGameDialog(props) {\n    const [userName, setUserName] = React.useState(\"\")\n    const [gameName, setGameName] = React.useState(\"\")\n    const [, setUser] = React.useContext(Context.UserContext)\n    const [, setGameState] = React.useContext(Context.GameStateContext)\n\n    const { open, setOpen } = props\n    const handleClose = () => { setOpen(false); };\n    const joinGame = async () => {\n        const newUser = await GameApi.Login(userName)\n        const newGameState = await GameApi.JoinGame(gameName, newUser)\n        setUser(newUser)\n        setGameState(newGameState)\n        setOpen(false)\n    }\n\n    return (\n        <DialogContainer onRequestClose={handleClose} aria-labelledby=\"customized-dialog-title\" isOpen={open}>\n            <DialogHeader onClose={handleClose}>\n                Join game\n            </DialogHeader>\n            <DialogContent>\n                <UserName userName={userName} setUserName={setUserName} />\n                <GameName gameName={gameName} setGameName={setGameName} />\n\n                <Button onClick={joinGame}>Join</Button>\n            </DialogContent>\n        </DialogContainer>\n    );\n}\n\nexport function CreateGameDialog(props) {\n    const [userName, setUserName] = React.useState(\"\")\n    const [gameName, setGameName] = React.useState(\"\")\n    const [, setUser] = React.useContext(Context.UserContext)\n    const [, setGameState] = React.useContext(Context.GameStateContext)\n\n    const { open, setOpen } = props\n    const handleClose = () => { setOpen(false); };\n    const createGame = async () => {\n        const newUser = await GameApi.Login(userName)\n        await GameApi.CreateGame(gameName, newUser)\n        const newGameState = await GameApi.JoinGame(gameName, newUser)\n        console.log(newUser)\n        console.log(newGameState)\n        \n        setUser(newUser)\n        setGameState(newGameState)\n        setOpen(false)\n    }\n\n    return (\n        <DialogContainer onRequestClose={handleClose} aria-labelledby=\"customized-dialog-title\" isOpen={open}>\n            <DialogHeader onClose={handleClose}>\n                Create game\n            </DialogHeader>\n            <DialogContent>\n                <UserName userName={userName} setUserName={setUserName} />\n                <GameName gameName={gameName} setGameName={setGameName} />\n\n                <Button onClick={createGame}>Create</Button>\n            </DialogContent>\n        </DialogContainer>\n    );\n}","/home/rollie/repos/drawing-app/frontend/src/Controls.js",["158"],"import styled from 'styled-components'\n\nconst ImageButtonContainer = styled.button`\n    padding: 0px;\n    margin: 0px;\n    border: 0px;\n    background: none;\n    outline: none;\n    cursor: pointer;\n`\n\nexport function ImageButton({image, height, onClick}) {\n    return (\n        <ImageButtonContainer onClick={onClick} image={image}>\n            <img src={image} height={height} />\n        </ImageButtonContainer>\n    )\n}\nexport const Button = styled.button`\n    cursor: pointer;\n    min-height: 36px;\n    background-color: #f9f9f9;\n    outline: none;\n    color: #E07D4D;\n    border: 1px solid #E07D4D;\n    margin: 0px 4px;\n    padding: 3px 8px;\n    border-radius: 9px;\n`","/home/rollie/repos/drawing-app/frontend/src/Components/Canvas.js",["159","160","161","162","163","164","165"],"import React, { useEffect } from 'react'\nimport { sleep } from '../Utils'\nimport styled from 'styled-components'\nimport PaintBrushImg from '../images/icons/paint-brush.png'\nimport { DrawAction, PasteAction } from '../History'\nimport { clearSelection, drawFn, DrawingStage } from './Drawing'\nimport DrawingContext from '../DrawingContext'\n\nexport const DrawingMode = {\n    DRAW: 'draw',\n    DRAW_SHAPE: 'draw-shape',\n    DRAW_LINE: 'draw-line',\n    ERASE: 'erase',\n    FILL: 'fill',\n    DISABLED: 'disabled',\n    SELECT: 'select',\n    MOVE: 'move'\n}\n\nexport const Shapes = {\n    CIRCLE: 'circle',\n    SQUARE: 'square',\n    TRIANGLE: 'triangle'\n}\n\nexport const MouseEventType = {\n    UP: \"up\",\n    DOWN: \"down\",\n    MOVE: \"move\"\n}\n\nclass MouseEvent {\n    constructor(eventType, position, pen, pressure) {\n        this.eventType = eventType\n        this.position = position\n        this.pen = pen\n        this.pressure = pressure\n    }\n\n    up() { return this.eventType === MouseEventType.UP }\n    down() { return this.eventType === MouseEventType.DOWN }\n    move() { return this.eventType === MouseEventType.MOVE }\n}\n\nconst StyledCanvas = styled.canvas`\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    display: ${props => props.hidden ? 'none;' : 'block;'}    \n`\n\nconst UICanvas = styled(StyledCanvas)`\n    z-index: 10;\n`\n\nconst clear = (canvas) => {\n    canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height)\n}\n\nexport const _getPos = (canvas, event) => {\n    const rect = canvas.getBoundingClientRect()\n    const position = (event?.changedTouches && event.changedTouches[0]) || event\n    return { x: Math.floor(position.clientX - rect.left), y: Math.floor(position.clientY - rect.top) }\n}\n\nconst mouseEvent = (canvas) => {\n    return new Promise((resolve, reject) => {\n        const makeHandler = type => event => {\n            if (event.type === 'pointerup' && event.button !== 0)\n                return\n\n            if (event.cancelable)\n                event.preventDefault()\n\n            canvas.removeEventListener('pointermove', moveHandler)\n            document.removeEventListener('pointerup', upHandler)\n            resolve(new MouseEvent(type, _getPos(canvas, event), event.pointerType === 'pen', event.pressure))\n        }\n\n        const moveHandler = makeHandler(MouseEventType.MOVE)\n        const upHandler = makeHandler(MouseEventType.UP)\n\n        canvas.addEventListener('pointermove', moveHandler)\n        document.addEventListener('pointerup', upHandler)\n    })\n}\n\nconst draw = async (drawParams) => {\n    const { startPoint, workingCanvas, layerCanvas, uiCanvas, mode, shape, fakeDrawing, layer, uiCanvasBackupBuffer } = drawParams\n    const workingContext = workingCanvas.getContext('2d')\n    const layerContext = layerCanvas.getContext('2d')\n    const uiContext = uiCanvas.getContext('2d')\n    layer.backupBuffer = undefined\n    uiCanvasBackupBuffer.current = undefined\n\n    var fakePointIdx = 0\n    const fakeMouseEvent = async (startTime) => {\n        switch (mode) {\n            case DrawingMode.DRAW:\n            case DrawingMode.ERASE: {\n                const points = fakeDrawing.points\n\n                await sleep(.001)\n                fakePointIdx = Math.min(fakePointIdx + 2, points.length - 1)\n\n                return new MouseEvent(\n                    fakePointIdx === points.length - 1 ? MouseEventType.UP : MouseEventType.MOVE,\n                    points[fakePointIdx],\n                    false,\n                    1)\n            }\n            case DrawingMode.DRAW_LINE: {\n                await sleep(1)\n                const t = Date.now() - startTime\n                const durationMs = 800\n                const pos = {\n                    x: startPoint.x + fakeDrawing.dx * t / durationMs,\n                    y: startPoint.y + fakeDrawing.dy * t / durationMs\n                }\n\n                return new MouseEvent(\n                    t >= durationMs ? MouseEventType.UP : MouseEventType.MOVE,\n                    pos,\n                    false,\n                    1)\n            }\n            case DrawingMode.FILL:\n            default:\n                break\n        }\n    }\n\n    const drawShape = async (drawFn) => {\n        const startTime = Date.now()\n        while (true) {\n            const mouseEvt = await (fakeDrawing ? fakeMouseEvent(startTime) : mouseEvent(uiCanvas))\n            const { pen, pressure, position } = mouseEvt\n            const dx = mouseEvt.position.x - startPoint.x\n            const dy = mouseEvt.position.y - startPoint.y\n\n            // clear temp canvas\n            clear(workingCanvas)\n            \n            drawFn({\n                context: mouseEvt.up() ? layerContext : workingContext,\n                startPoint,\n                endPoint: position,\n                dx,\n                dy,\n                pen,\n                pressure\n            })\n\n            if (mouseEvt.up()) {\n                return\n            }\n        }\n    }\n\n    var drawing = {\n        drawParams,\n        color: workingContext.color,\n        lineWidth: workingContext.lineWidth,\n    }\n\n    switch (mode) {  \n        case DrawingMode.MOVE: {\n            const workingImg = workingContext.getImageData(0, 0, workingCanvas.width, workingCanvas.height)\n            const uiImg = uiContext.getImageData(0, 0, uiCanvas.width, uiCanvas.height)\n            await drawShape(({ context, startPoint, dx, dy }) => {\n                workingContext.putImageData(workingImg, dx, dy)\n                uiContext.putImageData(uiImg, dx, dy)\n            })\n            break\n        }\n        default:\n            break\n    }\n\n    return drawing\n}\n\nconst CanvasContainer = styled.div`\n        position: relative;        \n        width: ${props => props.dimensions ? props.dimensions.width + 'px' : '100%'};\n        height: ${props => props.dimensions ? props.dimensions.height + 'px' : '100%'};\n    `\n\nconst cursorIcons = {\n    [DrawingMode.DRAW]: `url(${PaintBrushImg}) 4 26, auto`,\n    [DrawingMode.DRAW_SQUARE]: `url(${PaintBrushImg}) 4 26, auto`,\n    [DrawingMode.DRAW_CIRCLE]: `url(${PaintBrushImg}) 4 26, auto`,\n    [DrawingMode.DRAW_TRIANGLE]: `url(${PaintBrushImg}) 4 26, auto`,\n    [DrawingMode.DRAW_LINE]: `url(${PaintBrushImg}) 4 26, auto`,\n    [DrawingMode.ERASE]: `url(${PaintBrushImg}) 4 26, auto`,\n    [DrawingMode.FILL]: `url(${PaintBrushImg}) 4 26, auto`,\n    [DrawingMode.DISABLED]: 'auto',\n    [DrawingMode.SELECT]: `url(${PaintBrushImg}) 4 26, auto`,\n    [DrawingMode.MOVE]: `url(${PaintBrushImg}) 4 26, auto`,\n}\n\nconst getImageData = canvas => canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height)\nconst putImageData = (canvas, image) => canvas.getContext('2d').putImageData(image, 0, 0)\n\nexport const getDrawing = (layers) => {\n    var tmpCanvas = document.createElement(\"canvas\");\n    tmpCanvas.width = layers[0].canvasRef.current.width;\n    tmpCanvas.height = layers[0].canvasRef.current.height;\n    var tempContext = tmpCanvas.getContext(\"2d\");\n    for (const layer of layers) {\n        tempContext.drawImage(layer.canvasRef.current, 0, 0)\n        tempContext.drawImage(layer.workingCanvasRef.current, 0, 0)\n    }\n\n    // const imgData = getImageData(tmpCanvas)\n    const imgData = tmpCanvas.toDataURL('image/png').split(';base64,')[1]\n    // document.removeElement(tmpCanvas)\n    return imgData\n}\n\nexport default function Canvas(props) {\n    //const [currentBufferIdx, setCurrentBufferIdx] = React.useState(0)\n    const [canvasDimensions, setCanvasDimensions] = React.useState(undefined)\n    const activeLayerRef = React.useRef()\n    const canvasContainerRef = React.useRef()\n    const uiCanvasBackupBuffer = React.useRef(undefined)    \n\n    const { activeLayerCanvasRef, workingCanvasRef, uiCanvasRef } = props    \n    const useEffectAsync = (fn, deps) => {\n        useEffect(() => {\n            const handler = async () => {\n                fn(activeLayerCanvasRef.current, workingCanvasRef.current, uiCanvasRef.current)\n            }\n\n            handler()\n        }, [...deps, layers])\n    }\n\n    const { activeColor, lineWidth, mode, shape, fillShape, onDraw, replayList, staticImage, requestClear, setRequestClear } = props\n    const { requestCopy, setRequestCopy, requestPaste, setRequestPaste, requestDelete, setRequestDelete } = props\n    const { actionHistory, setActionHistory, layers, requestUndo, setRequestUndo, requestRedo, setRequestRedo } = props\n\n    const drawingContextRef = React.useRef(new DrawingContext({lineWidth, fillShape}))\n\n    const getCanvases = () => { return {\n        layerCanvas: activeLayerCanvasRef.current,\n        workingCanvas: workingCanvasRef.current,\n        uiCanvas: uiCanvasRef.current\n    }}\n\n    for (const layer of layers) {\n        if (layer.canvasRef === undefined) {\n            layer.canvasRef = React.createRef()\n            layer.workingCanvasRef = React.createRef()            \n        }\n    }\n\n    useEffect(() => {\n        for (const layer of layers) {    \n            if (layer.active) {\n                activeLayerRef.current = layer\n                activeLayerCanvasRef.current = layer.canvasRef.current\n                workingCanvasRef.current = layer.workingCanvasRef.current\n            }\n        }\n    })\n\n    const pushAction = (action) => {\n        setActionHistory(actions => {\n            return [...actions.filter(a => a.active), action]\n        })\n    }\n\n    const lastActiveUndoIdx = (buffer) => {\n        for (var i=0; i<buffer.length; i++) {\n            if (!buffer[i].active)\n                return i-1\n        }\n            \n        return buffer.length-1\n    }\n\n    const enrichProps = props => {\n        return {\n            ...props,\n            layerCanvas: activeLayerCanvasRef.current,\n            workingCanvas: workingCanvasRef.current,\n            uiCanvas: uiCanvasRef.current\n        }\n    }\n\n    const startDrawing = React.useCallback(async (event) => {\n        if (event.button !== 0 || staticImage)\n            return\n\n        if (event.cancelable)\n            event.preventDefault()\n\n        const startingImg = getImageData(activeLayerCanvasRef.current)\n\n        const firstEvent = new MouseEvent(\n            MouseEventType.DOWN,\n            _getPos(workingCanvasRef.current, event), \n            event.pointerType === 'pen', \n            event.pressure)\n\n        const drawShape = drawFn(mode, shape)\n        const state = {\n            stage: DrawingStage.DEFINE,\n            mode,\n            firstEvent,\n            curEvent: firstEvent\n        }\n        \n        while (true) {\n            const ev = state.curEvent\n            if (ev.up())\n                break\n            \n            state.drawingContext = drawingContextRef.current\n            clear(workingCanvasRef.current)\n            drawShape(getCanvases(), state)            \n            \n            state.curEvent = await mouseEvent(uiCanvasRef.current)   \n        }\n\n        state.stage = DrawingStage.COMMIT\n   \n        console.log('state: ', state)\n        clear(workingCanvasRef.current)\n        const action = new DrawAction(startingImg, mode, shape, state)\n        pushAction(action)\n        const res = action.exec(getCanvases())\n        onDraw(res) // TODO: what does this need to provide?\n    }, [activeColor, staticImage, mode, fillShape, actionHistory, onDraw, shape, layers, lineWidth])    \n\n    useEffect(() => {\n        const handleResize = () => {\n            // clearTimeout(window.resizeFinished)\n            // window.resizeFinished = setTimeout(() => {\n                if (uiCanvasBackupBuffer.current === undefined) {\n                    uiCanvasBackupBuffer.current = getImageData(uiCanvasRef.current)\n                }\n\n                const h = canvasContainerRef.current.offsetHeight\n                const w = canvasContainerRef.current.offsetWidth\n                const resizeCanvas = (canvas, img) => {\n                    canvas.width = w\n                    canvas.height = h\n                    setCanvas(canvas)\n                    putImageData(canvas, img)\n                }\n\n                for (const layer of layers) {\n                    if (layer.backupBuffer === undefined) {\n                        layer.backupBuffer = {\n                            canvas: getImageData(layer.canvasRef.current),\n                            workingCanvas: getImageData(layer.workingCanvasRef.current)\n                        }\n                    }\n                    resizeCanvas(layer.canvasRef.current, layer.backupBuffer.canvas)\n                    resizeCanvas(layer.workingCanvasRef.current, layer.backupBuffer.workingCanvas)\n                }\n                resizeCanvas(uiCanvasRef.current, uiCanvasBackupBuffer.current)\n            // }, 500)\n        }\n        window.addEventListener(\"resize\", handleResize)\n    }, [])\n    // Init canvases\n    useEffectAsync(async (layerCanvas, workingCanvas, uiCanvas) => {\n        const setCanvas = (canvas) => {\n            if (!canvas.init) {\n                canvas.init = true\n                const ctx = canvas.getContext('2d')\n                canvas.width = dimensions.width\n                canvas.height = dimensions.height\n                ctx.translate(0.5, 0.5) // TODO...why?\n                ctx.globalAlpha = 1;\n                ctx.imageSmoothingEnabled = false;\n            }\n        }\n        \n        var dimensions = canvasDimensions\n        if (canvasDimensions === undefined) {\n            // This is the first time we know dimensions - update the container to a fixed size\n            // to prevent resizing the canvas later\n            // canvasContainerRef.current.width = canvasContainerRef.current.offsetWidth/2\n            // canvasContainerRef.current.height = canvasContainerRef.current.offsetHeight/2\n            dimensions = { width: layerCanvas.offsetWidth, height: layerCanvas.offsetHeight }\n            setCanvasDimensions(dimensions)\n        }\n\n        setCanvas(layerCanvas)\n        setCanvas(workingCanvas)\n        setCanvas(uiCanvas)\n    }, [canvasDimensions])\n\n    // Handle mode change (requires cleanup of working buffer)\n    useEffectAsync((layerCanvas, workingCanvas, uiCanvas) => {\n        if (![DrawingMode.SELECT, DrawingMode.MOVE].includes(mode)) {\n            // This operation can't work on selection; write\n            // whatever is in working buffer to layer\n            // TODO: this probably doesn't work with layer change\n            clearSelection(getCanvases(), drawingContextRef.current)\n        }        \n    }, [mode])        \n\n    // Handle copy\n    useEffectAsync((layerCanvas, workingCanvas, uiCanvas) => {\n        if (requestCopy) {\n            const selection = drawingContextRef.current.selection\n            if (selection) {\n                const imgData = layerCanvas.getContext('2d').getImageData(selection.startPoint.x, selection.startPoint.y, selection.delta.x, selection.delta.y)\n                drawingContextRef.current.copiedImage = imgData\n                // Sadly, clipboard api seems difficult to work with\n            }\n            setRequestCopy(false)\n        }\n    }, [requestCopy])\n\n    // Handle paste\n    useEffectAsync((layerCanvas, workingCanvas, uiCanvas) => {\n        if (requestPaste) {\n            const copiedImg = drawingContextRef.current.copiedImage\n            if (copiedImg) {\n                clearSelection(getCanvases(), drawingContextRef.current)\n                const startingImg = getImageData(activeLayerCanvasRef.current)\n                const pos = _getPos(layerCanvas, requestPaste)\n                const action = new PasteAction(startingImg, copiedImg, pos)\n                pushAction(action)\n                action.exec(getCanvases())\n                //layerCanvas.getContext('2d').putImageData(copiedImg, pos.x - copiedImg.width / 2, pos.y - copiedImg.height / 2)\n                // TODO: actionHistory\n                // TODO: save to replay buffers\n            }\n            setRequestPaste(undefined)\n        }\n    }, [requestPaste])\n\n    // Handle delete\n    useEffectAsync((layerCanvas, workingCanvas, uiCanvas) => {\n        if (requestDelete) {\n            const selection = drawingContextRef.current.selection\n            if (selection) {\n                layerCanvas.getContext('2d').clearRect(selection.startPoint.x, selection.startPoint.y, selection.delta.x, selection.delta.y)\n                clearSelection(getCanvases(), drawingContextRef.current)\n                // TODO: actionHistory\n            }\n            setRequestDelete(false)\n        }\n    }, [requestDelete])\n\n    // Load static image if provided\n    useEffectAsync(async (layerCanvas, workingCanvas, uiCanvas) => {\n        if (staticImage) {\n            clear(layerCanvas)\n            if (staticImage !== \"empty\") {\n                let img = new Image()\n                img.crossOrigin = \"Anonymous\";\n                await new Promise(r => img.onload = r, img.src = staticImage)\n                // TODO: center\n                layerCanvas.getContext('2d').drawImage(img, 0, 0, layerCanvas.width, layerCanvas.height)\n            }\n        }\n    }, [staticImage])\n\n    // Handle clear request\n    useEffectAsync(async (layerCanvas, workingCanvas, uiCanvas) => {\n        if (requestClear) {\n            clearSelection(getCanvases(), drawingContextRef.current)\n            for (const layer of layers) {\n                clear(layer.canvasRef.current)\n            }\n            setRequestClear(false)\n            // TODO: actionHistory\n        }\n    }, [requestClear])\n\n    // Handles undo/redo\n    useEffectAsync(async (layerCanvas, workingCanvas, uiCanvas) => {\n        const idx = lastActiveUndoIdx(actionHistory)\n        if (requestUndo && idx >= 0) {\n            actionHistory[idx].active = false\n            actionHistory[idx].undo(getCanvases())\n            setActionHistory([...actionHistory])\n        } else if (requestRedo && idx < actionHistory.length - 1) {\n            actionHistory[idx+1].active = true\n            actionHistory[idx+1].exec(getCanvases())\n            setActionHistory([...actionHistory])            \n            // layerCanvas.getContext('2d').putImageData(undoBuffer[activeBufferIdx].imageData, 0, 0)\n        }\n        setRequestUndo(false)\n        setRequestRedo(false)\n    }, [requestUndo, requestRedo, actionHistory])\n\n    // Handle replay\n    useEffectAsync(async (layerCanvas, workingCanvas, uiCanvas) => {\n        if (!replayList)\n            return\n\n        console.log(\"replaying!\")\n\n        clear(layerCanvas)\n\n        const setContextData = (context, drawing) => {\n            context.lineWidth = drawing.lineWidth\n            context.color = drawing.color\n            context.fillStyle = drawing.color\n            context.strokeStyle = drawing.color\n        }\n\n        for (const drawing of replayList) {\n            const params = drawing.drawParams\n            setContextData(layerCanvas.getContext('2d'), drawing)\n            setContextData(workingCanvas.getContext('2d'), drawing)\n            await draw({\n                ...params,\n                workingCanvas,\n                layerCanvas,\n                uiCanvas,\n                fakeDrawing: drawing\n            })\n        }\n        console.log(\"done replay\")\n\n    }, [replayList])\n\n    const setCanvas = React.useCallback((canvas) => {\n        const context = canvas.getContext('2d')\n        context.globalCompositeOperation = mode === DrawingMode.ERASE\n            ? 'destination-out'\n            : 'source-over'//'hard-light'\n        context.lineWidth = lineWidth\n        context.color = activeColor\n        context.fillStyle = activeColor\n        context.strokeStyle = activeColor\n        canvas.style.cursor = cursorIcons[mode]\n    }, [activeColor, lineWidth, layers, mode])\n\n    // Handle property change\n    useEffectAsync(async (layerCanvas, workingCanvas, uiCanvas) => {        \n\n        setCanvas(layerCanvas)\n        setCanvas(workingCanvas)\n        setCanvas(uiCanvas)\n    }, [activeColor, lineWidth, layers, mode])\n\n    useEffect(() => {\n        drawingContextRef.current.lineWidth = lineWidth\n        drawingContextRef.current.fillShape = fillShape\n    }, [fillShape, lineWidth])\n\n    // const activeLayerIndex = layers.findIndex(l => l.active)\n    return (\n        <CanvasContainer ref={canvasContainerRef} >\n            {layers.map(v => <React.Fragment key={v.id}>\n                <StyledCanvas hidden={!v.visible} id={v.id} ref={v.canvasRef}/>\n                <StyledCanvas hidden={!v.visible} id={'working_'+v.id} ref={v.workingCanvasRef}/>                \n                </React.Fragment>)}\n            <UICanvas id=\"uiCanvas\" ref={uiCanvasRef} onPointerDown={startDrawing} />\n        </CanvasContainer>\n    )\n}","/home/rollie/repos/drawing-app/frontend/src/Utils.js",["166","167","168"],"import React, { useEffect } from 'react'\nimport ReactDOM from 'react-dom'\n\nexport function capitalize(s) {\n    return s[0].toUpperCase() + s.slice(1);\n}\n\nexport function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport function contextsToProps(contexts) {\n    const props = {}\n    for (const [key, value] of Object.entries(contexts)) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const [getter, setter] = React.useContext(value)\n        props[key] = getter\n        props['set' + capitalize(key)] = setter\n    }\n\n    return props\n}\n\nexport function usePrevState(state) {\n    const [curState, setCurState] = React.useState(state)\n    // const [prevState, setPrevState] = React.useState(state)\n\n    useEffect(() => {\n        if (state !== curState) {\n            console.log('state change internal')\n            setCurState(state)         \n        }\n    }, [state])\n\n    \n    \n    return curState\n}\n\nexport function useStateChange(state, handler) {\n    const prevState = usePrevState(state)\n    React.useEffect(() => {\n        if (state !== prevState) {\n            handler(prevState, state)\n        }\n    }, [state, prevState])\n}","/home/rollie/repos/drawing-app/frontend/src/GameState.js",[],"/home/rollie/repos/drawing-app/frontend/src/Components/GameSummary.js",["169"],"import React from 'react';\nimport styled from 'styled-components'\nimport * as Context from '../Context'\nimport Modal from 'react-modal';\nimport { Button } from '../Controls'\nimport { DialogContainer } from './GameDialogs'\n\nconst SummaryContainer = styled.span`\n    width: 180px;\n    height: 120px;\n`\n\nfunction DescriptionEntrySummary({ descEntry }) {\n    return (\n        <SummaryContainer>\n            <span>{descEntry.description}</span>\n        </SummaryContainer>\n    )\n}\n\nconst StyledImg = styled.img`\n    height: 100%;\n    width: 100%;\n    background: #ffffff;\n`\nfunction ImageEntrySummary({ imageEntry }) {\n    return (\n        <SummaryContainer>\n            <StyledImg src={imageEntry.imageUrl} />\n        </SummaryContainer>\n    )\n}\n\nfunction EntrySummary({ entry }) {\n    return (<>\n        { entry.imageUrl ? <ImageEntrySummary imageEntry={entry} /> : <DescriptionEntrySummary descEntry={entry} />}\n    </>\n    )\n}\n\nconst BookSummaryContainer = styled.div`\n    display: flex;\n`\nfunction BookSummary({ book }) {\n    return (\n        <BookSummaryContainer>\n            {book.entries.map((entry) => <EntrySummary key={entry} entry={entry} />)}\n        </BookSummaryContainer>\n    )\n}\nexport function GameSummary(props) {\n    const [open, setOpen] = React.useState(true)\n    const [gameState, setGameState] = React.useContext(Context.GameStateContext)\n    const [, setUser] = React.useContext(Context.UserContext)\n\n    const exitGame = () => {\n        setGameState(undefined)\n        setUser(undefined)\n        setOpen(false)\n    }\n    console.log(open)\n    return (\n        <DialogContainer style={{ overlay: { display: 'flex', alignItems: 'center', justifyContent: 'center' } }} onRequestClose={() => setOpen(false)} isOpen={open}>\n            <div>\n                {gameState.books.map((book) => <BookSummary key={book} book={book} />)}\n            </div>\n\n            <div>\n                <Button onClick={exitGame}>Exit game</Button>\n            </div>\n        </DialogContainer>\n    )\n}","/home/rollie/repos/drawing-app/frontend/src/History.js",["170"],"import { v4 as uuidv4 } from 'uuid'\nimport { drawFn } from './Components/Drawing'\n\nexport const ActionType = {\n    DRAW: 'draw',\n    CHANGE_TOOL: 'change-tool',\n    CHANGE_LAYER: 'change-layer'\n}\n\nexport class Action {\n    constructor() {\n        this.active = true\n        this.id = uuidv4()\n    }\n\n    describe = () => `${activeIcon(this)} ${this.describeInternal()}`\n}\n\nconst activeIcon = (action) => action.active ? '*' : ' '\nconst clear = canvas => canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height)\n\nexport class DrawAction extends Action {\n    constructor(image, mode, shape, state) {\n        super()\n        this.image = image\n        this.mode = mode\n        this.shape = shape\n        this.state = state\n    }\n\n    describeInternal = () => `Draw`\n\n    undo = (canvases) => {\n        // TODO: undo/redo of select doesn't update the drawing context, but needs to\n        const canvasCtx = canvases.layerCanvas.getContext('2d')\n        console.log(canvasCtx, this.image, this.state)\n        canvasCtx.putImageData(this.image, 0, 0)\n    }\n\n    exec = (canvases) => {\n        const drawShape = drawFn(this.mode, this.shape)\n        return drawShape(canvases, this.state)\n    }\n}\n\nexport class PasteAction extends Action {\n    constructor(prevImg, pastedImg, location) {\n        super()\n        this.prevImg = prevImg\n        this.pastedImg = pastedImg\n        this.location = location\n    }\n\n    describeInternal = () => `Paste`\n\n    undo = (canvases) => {\n        const canvasCtx = canvases.layerCanvas.getContext('2d')\n        canvasCtx.putImageData(this.prevImg, 0, 0)\n    }\n\n    exec = ({layerCanvas}) => {\n        layerCanvas\n            .getContext('2d')\n            .putImageData(\n                this.pastedImg, \n                this.location.x - this.pastedImg.width / 2, \n                this.location.y - this.pastedImg.height / 2\n            )\n    }\n\n}\nexport class LayerToggleAction extends Action {\n    constructor(layer) {\n        super()\n        this.layer = layer\n        this.active = layer.active\n    }\n\n    describeInternal = () => `Layer toggle - ${this.layer.id}`\n\n    undo = ({setLayers}) => {\n        this.layer.visible = !this.layer.visible\n        setLayers(layers => {\n            if (this.active) {\n                this.layer.active = true\n                layers.forEach(l => l.active = false)\n            }            \n            return [...layers]\n        })\n    }\n\n    exec = ({setLayers}) => {\n        this.layer.visible = !this.layer.visible\n        setLayers(layers => {\n            if (this.active) {\n                const idx = layers.findIndex(l => l.id === this.layer.id)\n                this.layer.active = false\n                layers[idx === layers.length - 1 ? idx-1 : idx+1].active = true\n            }\n            return [...layers]\n        })\n    }\n}\n\nexport class LayerSelectAction extends Action {\n    constructor(layer, prevLayer) {\n        super()\n        this.layer = layer\n        this.prevLayer = prevLayer\n        this.visible = layer.visible\n    }\n\n    describeInternal = () => `Layer select - ${this.layer.id} (prev: ${this.prevLayer.id})`\n\n    undo = ({setLayers}) => {\n        this.layer.active = false\n        this.prevLayer.active = true\n        this.layer.visible = this.visible\n        setLayers(layers => [...layers])\n    }\n\n    exec = ({setLayers}) => {\n        this.layer.active = true\n        this.prevLayer.active = false\n        this.layer.visible = true\n        setLayers(layers => [...layers])\n    }\n}\n\nexport class LayerDeleteAction extends Action {\n    constructor(layer, idx) {\n        super()\n        this.layer = layer\n        this.idx = idx\n    }\n\n    describeInternal = () => `Layer delete - ${this.layer.id}`\n\n    undo = ({setLayers}) => {\n        setLayers(layers => {\n            if (this.layer.active)\n                layers.forEach(layer => layer.active = false)\n            return [...layers.slice(0, this.idx), this.layer, ...layers.slice(this.idx, layers.length)]\n        })\n    }\n\n    exec = ({setLayers}) => {\n        setLayers(layers => {\n            if (this.layer.active) {\n                // Pick a new active layer\n                let idx = layers.findIndex(l => l.id === this.layer.id)\n                // TODO: make visible, and undo as well\n                layers[idx === layers.length - 1 ? idx-1 : idx+1].active = true\n            }\n            return layers.filter(layer => layer.id !== this.layer.id)\n        })\n    }\n}\n\nexport class LayerCreateAction extends Action {\n    constructor(layer, prevActiveLayer) {\n        super()\n        this.layer = layer\n        this.prevActiveLayer = prevActiveLayer\n    }\n\n    describeInternal = () => `Layer create`\n\n    undo = (ctx) => {\n        this.prevActiveLayer.active = true\n        ctx.setLayers(layers => layers.filter(layer => layer.id !== this.layer.id))\n    }\n\n    exec = (ctx) => {\n        this.prevActiveLayer.active = false\n        ctx.setLayers(layers => [...layers, this.layer])\n    }\n}","/home/rollie/repos/drawing-app/frontend/src/Components/CanvasProps.js",[],"/home/rollie/repos/drawing-app/frontend/src/Components/ActionHistory.js",[],"/home/rollie/repos/drawing-app/frontend/src/Components/Drawing.js",["171","172","173","174"],"import {DrawingMode, MouseEventType, Shapes, _getPos} from './Canvas'\nimport FloodFill from 'q-floodfill'\n\nexport const DrawingStage = {\n    DEFINE: 'define',\n    COMMIT: 'commit',\n    REPLAY: 'replay'\n}\n\nconst pushContext = (canvases, drawingContext) => {\n    for (const canvas of Object.values(canvases)) {\n        const canvasContext = canvas.getContext('2d')\n        canvasContext.save()\n        canvasContext.lineWidth = drawingContext.lineWidth\n    }\n}\n\nconst popContext = (canvases) => {\n    for (const canvas of Object.values(canvases)) {\n        canvas.getContext('2d').restore()\n    }\n}\n\nexport const drawFn = (mode, shape) => {\n    const fn = drawFnInner(mode, shape)\n    return (canvases, state) => {\n        pushContext(canvases, state.drawingContext)\n        fn(canvases, state)\n        popContext(canvases)\n    }\n}\n\nexport const drawFnInner = (mode, shape) => {\n    switch(mode) {\n        case DrawingMode.DRAW_SHAPE:\n            switch(shape) {\n                case Shapes.SQUARE:\n                    return drawSquare\n                case Shapes.CIRCLE:\n                    return drawCircle\n                case Shapes.TRIANGLE:\n                    return drawTriangle\n                default:\n                    throw new Error(`unknown shape '${shape}'`)\n            }\n        case DrawingMode.DRAW_LINE:\n            return drawLine\n        case DrawingMode.DRAW:\n        case DrawingMode.ERASE:\n            return drawPath\n        case DrawingMode.FILL:\n            return fill\n        case DrawingMode.SELECT:\n            return select\n        case DrawingMode.MOVE:\n            return move\n        default:\n            throw new Error(`unknown drawing mode '${mode}'`)\n    }\n}\n\nconst clear = (canvas) => {\n    canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height)\n}\n\nconst drawCurve = (points, path) => {\n    const t = 1\n    const i = points.length - 2\n    var p0 = (i > 0) ? points[i - 1] : points[0]\n    var p1 = points[i]\n    var p2 = points[i + 1] // This is the one we're going to\n    var p3 = (i !== points.length - 2) ? points[i + 2] : p2\n    var cp1x = p1.x + (p2.x - p0.x) / 6 * t\n    var cp1y = p1.y + (p2.y - p0.y) / 6 * t\n\n    var cp2x = p2.x - (p3.x - p1.x) / 6 * t\n    var cp2y = p2.y - (p3.y - p1.y) / 6 * t\n    path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y)\n}\n\nfunction drawPath(canvases, state) {\n    const canvas = state.stage === DrawingStage.DEFINE && state.mode !== DrawingMode.ERASE ? canvases.workingCanvas : canvases.layerCanvas\n    state.paths = state.paths ?? []\n    state.points = state.points ?? []\n    const paths = state.paths\n    const points = state.points\n\n    var path = paths[paths.length-1]\n    const lineWidth = state.drawingContext.lineWidth\n\n    if (state.stage === DrawingStage.DEFINE) {\n        const curPoint = state.curEvent.position\n        points.push(curPoint)\n        if (path === undefined || lineWidth !== path.lineWidth) {\n            path = new Path2D()\n            path.moveTo(curPoint.x, curPoint.y)\n            path.lineWidth = lineWidth\n            paths.push(path)\n        }\n    }\n\n    if (points.length === 1) {\n        // const x = points[0].x - lineWidth/2\n        // const y = points[0].y - lineWidth/2\n        // drawCircleOnce(canvas, {location: {x: x, y: y}, dx: lineWidth, dy: lineWidth, fillShape: true})\n        const context = canvas.getContext('2d')\n        const prevLineWidth = context.lineWidth\n        context.beginPath()\n        context.lineWidth = 1\n        context.arc(points[0].x, points[0].y, lineWidth / 2, 0, 2 * Math.PI)\n        context.fill()\n        context.lineWidth = prevLineWidth\n    } else {\n        \n        if (state.stage === DrawingStage.DEFINE) {\n            drawCurve(points, path)\n        }\n        \n        const context = canvas.getContext('2d')\n\n        paths.forEach(p => {\n            const lineWidth = context.lineWidth\n            context.lineWidth = p.lineWidth\n            context.stroke(p)\n            context.lineWidth = lineWidth\n        })\n    }\n}\n\nconst getStateInfo = (state) => {\n    const startPoint = state.firstEvent.position\n    const endPoint = state.curEvent.position\n    const dx = endPoint.x - startPoint.x\n    const dy = endPoint.y - startPoint.y\n    return {\n        ...state,\n        startPoint,\n        endPoint,\n        dx,\n        dy,\n        rx: dx / 2,\n        ry: dy / 2\n    }\n}\n\nexport function drawSquare(canvases, state) {\n    const canvas = state.stage === DrawingStage.DEFINE ? canvases.workingCanvas : canvases.layerCanvas\n    const context = canvas.getContext('2d')\n    const {startPoint, dx, dy} = getStateInfo(state)\n    state.drawingContext.fillShape\n        ? context.fillRect(startPoint.x, startPoint.y, dx, dy)\n        : context.strokeRect(startPoint.x, startPoint.y, dx, dy)\n}\n\nexport function drawCircle(canvases, state) {\n    const canvas = state.stage === DrawingStage.DEFINE ? canvases.workingCanvas : canvases.layerCanvas\n    const fillShape = state.drawingContext.fillShape\n    const {startPoint, rx, ry} = getStateInfo(state)\n\n    const context = canvas.getContext('2d')\n    context.save()\n    if (fillShape)\n        context.lineWidth=1\n    context.beginPath()\n    context.ellipse(startPoint.x + rx, startPoint.y + ry, Math.abs(rx), Math.abs(ry), 0, 0, 2 * Math.PI)\n    if (fillShape)\n        context.fill()\n    context.stroke()\n    context.restore()\n}\n\nexport function drawTriangle(canvases, state) {\n    const canvas = state.stage === DrawingStage.DEFINE ? canvases.workingCanvas : canvases.layerCanvas\n    const context = canvas.getContext('2d')\n    const fillShape = state.drawingContext.fillShape\n    const {startPoint, endPoint, dx} = getStateInfo(state)\n    \n    context.save()\n    context.beginPath()\n    if (fillShape)\n        context.lineWidth=1\n    context.moveTo(startPoint.x + dx / 2, startPoint.y)\n    context.lineTo(startPoint.x, endPoint.y)\n    context.lineTo(endPoint.x, endPoint.y)\n    context.lineTo(startPoint.x + dx / 2, startPoint.y)\n    if (fillShape)\n        context.fill()\n    context.stroke()\n    context.restore()\n}\n\nexport function drawLine(canvases, state) {\n    const canvas = state.stage === DrawingStage.DEFINE ? canvases.workingCanvas : canvases.layerCanvas\n    const {startPoint, endPoint} = getStateInfo(state)\n    const context = canvas.getContext('2d')\n    context.beginPath()\n    context.moveTo(startPoint.x, startPoint.y)\n    context.lineTo(endPoint.x, endPoint.y)\n    context.stroke()\n}\n\nexport function fill(canvases, state) {\n    const {layerCanvas} = canvases\n    if (state.stage === DrawingStage.DEFINE){\n        // We don't work with the define stage for fill\n        return true\n    }\n\n    const context = layerCanvas.getContext('2d')\n    const {startPoint} = getStateInfo(state)\n\n    const imgData = context.getImageData(0, 0, layerCanvas.width, layerCanvas.height)\n    \n    const floodFill = new FloodFill(imgData)\n    floodFill.fill(context.color, Math.floor(startPoint.x), Math.floor(startPoint.y), 0)\n    context.putImageData(floodFill.imageData, 0, 0)\n}\n\nexport const clearSelection = ({layerCanvas, workingCanvas, uiCanvas}, drawingContext) => {\n    console.log(\"Clear selection...?\")\n    drawingContext.selection = undefined    \n    clear(uiCanvas)\n}\n\nfunction select(canvases, state) {\n    const {layerCanvas, workingCanvas, uiCanvas} = canvases\n    const {startPoint, dx, dy, drawingContext} = getStateInfo(state)\n\n    if (state.stage === DrawingStage.COMMIT) {        \n        if (dx > 0 && dy > 0) {\n            drawingContext.selection = {startPoint, delta: {x: dx, y: dy}}\n        } else {\n            drawingContext.selection = undefined\n        }\n\n        return\n    }\n    clear(uiCanvas)\n    const uiContext = uiCanvas.getContext('2d')\n    uiContext.save()\n    uiContext.strokeStyle = '#000000'\n    uiContext.lineWidth = 1\n    uiContext.setLineDash([5, 15])\n    uiContext.strokeRect(startPoint.x, startPoint.y, dx, dy)\n    uiContext.restore()\n}\n\n\nfunction move(canvases, state) {\n    const {layerCanvas, workingCanvas, uiCanvas} = canvases\n    const {dx, dy, drawingContext} = getStateInfo(state)\n    const layerContext = layerCanvas.getContext('2d')\n    const workingContext = workingCanvas.getContext('2d')\n    const uiContext = uiCanvas.getContext('2d')\n    const selection = drawingContext.selection\n\n    if (!selection) {\n        // Nothing selected, nothing to move\n        return true\n    }\n\n    console.log(selection)\n\n    if (!state.workingImg) {\n        // Beginning of operation\n        // Note the +1/-1 offsets; if we select from 10,10 til 20,20, we have dx=10, but our selectedimage is 11 pixels;\n        // these offsets account for that. The math doesn't quite add up for the clear though; why do we need the -1s?\n        // Maybe difference in how clear rect works...\n        state.workingImg = layerContext.getImageData(selection.startPoint.x, selection.startPoint.y, selection.delta.x+1, selection.delta.y+1)\n        layerContext.clearRect(selection.startPoint.x-1, selection.startPoint.y-1, selection.delta.x+1, selection.delta.y+1)\n        state.uiImg = uiContext.getImageData(0, 0, uiCanvas.width, uiCanvas.height)\n    }        \n\n    uiContext.putImageData(state.uiImg, dx, dy)\n\n    if (state.stage === DrawingStage.DEFINE) {\n        workingContext.putImageData(state.workingImg, selection.startPoint.x+dx, selection.startPoint.y+dy)\n    } else {\n        layerContext.save()\n        layerContext.globalCompositeOperation = 'source-atop'\n        layerContext.putImageData(state.workingImg, selection.startPoint.x+dx, selection.startPoint.y+dy)\n        layerContext.restore()\n        selection.startPoint.x += dx\n        selection.startPoint.y += dy\n    }\n    \n    \n}\n","/home/rollie/repos/drawing-app/frontend/src/Components/LayerBox.js",["175","176","177","178","179","180","181","182","183","184","185","186","187","188","189","190","191","192","193"],"import React, { useEffect } from 'react'\nimport styled from 'styled-components'\nimport * as Context from '../Context'\nimport ToggleButton from '@material-ui/lab/ToggleButton';\nimport ToggleButtonGroup from '@material-ui/lab/ToggleButtonGroup';\nimport {sleep} from '../Utils'\nimport { DrawingMode } from './Canvas'\nimport { RgbaStringColorPicker } from \"react-colorful\";\nimport \"react-colorful/dist/index.css\"\nimport { v4 as uuidv4 } from 'uuid'\nimport DeleteLayerIcon from '@material-ui/icons/Close'\nimport VisibleIcon from '@material-ui/icons/Visibility'\nimport NotVisibleIcon from '@material-ui/icons/VisibilityOff'\nimport { LayerCreateAction, LayerToggleAction, LayerDeleteAction, LayerSelectAction } from '../History'\nimport Slider from '@material-ui/core/Slider';\nimport ClearCanvasImg from '../images/clear-canvas.png'\nimport { withStyles } from '@material-ui/core';\nimport AddIcon from '@material-ui/icons/AddCircle'\n\nconst Container = styled.div`\n    display: flex;\n    flex-direction: column;\n    height: 80vh;\n`\n\nconst ControlPanel = styled.div`\n    background-color: #FFF1BD;\n    border: solid #FDAA4F 3px;\n    border-radius: 40px;\n    box-shadow: 8px 5px 5px #706A54cc;\n    padding: 20px 10px;\n    margin: 30px 50px;\n    min-height: 80%;\n`\n\nconst SVG = styled.svg`\n    display: inline-flex;\n    width: 100%;\n    height: 100%;\n    margin: 0px 0px;\n    padding: 0px;\n    ${props => props.selected && `background-color: #22222255;`}\n`\n\nconst getRGB = (hexColor) => {\n    var match = hexColor.match(/rgba?\\((\\d{1,3}), ?(\\d{1,3}), ?(\\d{1,3})\\)?(?:, ?(\\d(?:\\.\\d+)?)\\))?/);\n    return match ? {\n        red: match[1],\n        green: match[2],\n        blue: match[3],\n        alpha: match[4]\n    } : {};\n}\n\nfunction colorsEqual(c1, c2) {\n    const o1 = getRGB(c1)\n    const o2 = getRGB(c2)\n    return o1.red === o2.red && o1.green === o2.green && o1.blue === o2.blue && Math.abs(o1.alpha - o2.alpha) < .1\n}\n\nconst CircleContainer = styled.div`\n    width: 40px;\n    height: 40px;\n`\nfunction ColorCircle(props) {\n    const [activeColor, setActiveColor] = React.useContext(Context.ActiveColorContext)\n    const [colorPalette, setColorPalette] = React.useContext(Context.ColorPalette)\n    const width = props.width ?? 15\n    \n    const clickHandler = React.useCallback((e) => {\n        e.preventDefault()\n        if (e.type === \"click\")\n            setActiveColor(props.color)\n        else if (e.type === 'contextmenu')\n            setColorPalette(colorPalette.filter(color => color != props.color))\n    }, [colorPalette, activeColor])\n    return (\n        <CircleContainer>\n            <SVG onContextMenu={clickHandler} onClick={clickHandler} selected={colorsEqual(activeColor, props.color)}>\n                <circle cx={20} cy={20} r={width} stroke={props.color} strokeWidth=\"1\" fill={props.color} />\n            </SVG>\n        </CircleContainer>\n    )\n}\n\nconst ColorCircleContainer = styled.div`\n    display: flex;\n    justify-content: left;\n    align-items: center;\n    min-height: 30px;\n    flex-wrap: wrap;\n`\nconst ColorPaletteContainer = styled.div`\n    margin-top: 8px;\n`\n\nconst Label = styled.div`\n    cursor: arrow;\n    user-select: none;\n    flex: 1;\n`\n\nconst ClearButtonStyled = styled.img`\n    width: 90%;\n    cursor: pointer;\n`\n\nfunction ClearButton() {\n    const [, setRequestClear] = React.useContext(Context.RequestClearContext)\n\n    return (\n        <ClearButtonStyled src={ClearCanvasImg} onClick={() => setRequestClear(true)} />\n    )\n}\nfunction ColorPalette() {\n    const [colorPalette, setColorPalette] = React.useContext(Context.ColorPalette)\n    const [activeBook] = React.useContext(Context.ActiveBookContext)\n\n    React.useEffect(() => {\n        setColorPalette([])\n    }, [activeBook])\n\n    return (\n        <ColorPaletteContainer>\n            <Label>Palette</Label>\n            <ColorCircleContainer>\n                {colorPalette.map((value) => {\n                    return <ColorCircle key={value} color={value} />\n                })}\n            </ColorCircleContainer>\n        </ColorPaletteContainer>\n    )\n}\n\nconst StrokeWidthContainer = styled.div`\n`\n\nconst StrokeWidthValue = styled.input`\n    width: 20px;\n`\n\nconst FontSlider = withStyles({\n    root: {\n        flex: 1\n    }    \n})(Slider)\n\nconst FontControlBox = styled.div`\n    display: flex;\n    align-items: center;\n`\n\nconst SampleBrushDot = styled.div`\n    width: 40px;\n    height: 40px;\n    margin-left: 10px;\n    border: solid #FDAA4F 1px;\n    background: #ffffff;\n`\n\nfunction StrokeWidth() {\n    const [lineWidth, setLineWidth] = React.useContext(Context.LineWidthContext)\n\n    const handler = (e, newWidth) => {\n        const val = e.target.value\n        setLineWidth(newWidth)\n    }\n    return (\n        <StrokeWidthContainer>\n            <Label>Stroke width</Label>\n            <FontControlBox>\n                <FontSlider value={lineWidth} onChange={handler} min={1} max={72} valueLabelDisplay=\"auto\" />\n                <SampleBrushDot>\n                    <ColorCircle color={\"black\"} width={lineWidth/2} />\n                </SampleBrushDot>\n            </FontControlBox>         \n        </StrokeWidthContainer>\n    )\n}\n\nconst ColorPicker = styled(RgbaStringColorPicker)`\n    width: 100%;\n`\n\nconst LayerOuterContainer = styled.div`\n    width: 100%;\n    border: solid #FDAA4F 3px;\n    border-radius: 15px;\n    overflow: hidden;\n`\nconst LayerContainer = styled.div`\n    width: 100%;\n    display: flex;\n    background-color: ${props => props.active ? '#f9f9f9' : '#ffffff'};\n    height: 35px;\n    display: flex;\n    align-items: center;\n    cursor: default;\n`\n\nconst VisibleToggleContainer = styled.span`\n    margin-left: 6px;\n    cursor: pointer;\n\n`\n\nfunction VisibleToggle({layer}) {\n    const [layers, setLayers] = React.useContext(Context.LayerContext)\n    const [, , pushAction] = React.useContext(Context.ActionHistoryContext)\n\n    const toggleVisible = React.useCallback((e) => {\n        if (layer.visible && layers.filter(l => l.visible).length == 1) {\n            console.log(\"You can't toggle off the last visible layer!\")\n            return\n        }\n        e.stopPropagation()\n        const action = new LayerToggleAction(layer)\n        action.exec({setLayers})\n        pushAction(action)\n    }, [layers])\n\n    return (\n        <VisibleToggleContainer onClick={toggleVisible}>\n        {layer.visible && <VisibleIcon />}\n        {!layer.visible && <NotVisibleIcon />}\n        </VisibleToggleContainer>\n    )\n}\n\nconst LayerText = styled.span`\n    flex: 1;\n    user-select:none;\n`\n\nconst DeleteLayerButton = styled(DeleteLayerIcon)`\n    margin-right: 6px;\n    cursor: pointer;\n`\n\nconst RenameInput = styled.input`\n    width: 100%;\n    text-align: center;\n`\n\nfunction Layer({layer}) {\n    const [layers, setLayers] = React.useContext(Context.LayerContext)\n    const [, , pushAction] = React.useContext(Context.ActionHistoryContext)\n    const [renaming, setRenaming] = React.useState(false)\n    const [layerName, setLayerName] = React.useState(layer.name)\n    \n    const selectLayer = React.useCallback(() => {\n        if (layer.active)\n            return\n\n        const currentLayer = layers.find(layer => layer.active)\n        const action = new LayerSelectAction(layer, currentLayer)\n        action.exec({setLayers})\n        pushAction(action)\n    }, [layers])\n\n    const deleteLayer = React.useCallback((e) => {\n        e.stopPropagation()\n        if (layers.length === 1)\n            return\n\n        let idx = layers.findIndex(l => l.id === layer.id)\n        const action = new LayerDeleteAction(layer, idx)\n        action.exec({setLayers})\n        pushAction(action)\n    }, [layers])\n\n    console.log(layer)\n\n    React.useEffect(() => {\n        if (renaming) {\n            const keyHandler = (e) => {\n                if (e.keyCode === 27) {\n                    setLayerName(layer.name) // Revert change\n                    setRenaming(false)\n                } else if (e.keyCode === 13) {\n                    setRenaming(false)\n                }\n            }\n            const pointerHandler = () => {\n                setRenaming(false)\n            }\n\n            window.addEventListener('pointerup', pointerHandler, false)\n            window.addEventListener('keydown', keyHandler, false)\n            return () => {\n                window.removeEventListener('keydown', keyHandler, false)\n                window.removeEventListener('pointerup', pointerHandler, false)\n            }\n        }\n    }, [renaming])\n\n    React.useEffect(() => {\n        if (!renaming) {\n            layer.name = layerName\n        }\n    }, [renaming, layerName])\n\n    const updateLayerName = (newName) => {\n        setLayerName(newName)\n    }\n\n    return (\n        <LayerContainer onClick={selectLayer} active={layer.active} onDoubleClick={() => setRenaming(true)}>\n            <VisibleToggle layer={layer} />\n            {!renaming && <LayerText>{layerName}</LayerText>}\n            {renaming && \n                <LayerText>\n                    <RenameInput autoFocus type=\"text\" \n                        value={layerName} \n                        onChange={e => updateLayerName(e.target.value)} \n                        onFocus={e => e.target.select()}\n                        onBlur={e => setRenaming(false)}\n                    />\n                </LayerText>}\n            <DeleteLayerButton onClick={deleteLayer}/>\n        </LayerContainer>\n    )\n}\n\nconst NewLayerButton = styled.button`\n\n`\n\nconst LayerListContainer = styled.div`\n    \n`\n\nconst LayerLabelContainer = styled.div`\n    display: flex;\n`\n\nconst AddIconStyled = styled(AddIcon)`\n    cursor: pointer;\n`\n\nfunction LayerList() {\n    const [layers, setLayers] = React.useContext(Context.LayerContext)\n    const [, , pushAction] = React.useContext(Context.ActionHistoryContext)\n\n    const addLayer = React.useCallback(() => {\n        const prevActiveLayer = layers.find(layer => layer.active)\n        const newLayer = {\n            name: 'New Layer',\n            id: uuidv4(),\n            active: true,\n            visible: true\n        }\n        const action = new LayerCreateAction(newLayer, prevActiveLayer)\n        action.exec({setLayers})\n        pushAction(action)  \n    }, [layers])\n\n    return (\n        <LayerListContainer>\n            <LayerLabelContainer>\n                <Label>Layers</Label>\n                <AddIconStyled onClick={addLayer}>+</AddIconStyled>\n            </LayerLabelContainer>\n            <LayerOuterContainer>\n                {[...layers].reverse().map(layer => <Layer key={layer.id} layer={layer} />)}\n            </LayerOuterContainer>\n        </LayerListContainer>\n    )\n}\n\nexport default function LayerBox() {\n    const [activeColor, setActiveColor] = React.useContext(Context.ActiveColorContext)\n    const [gameState] = React.useContext(Context.GameStateContext)\n    const presentingSummary = [\"PresentingSummary\"].includes(gameState?.gameStatus)\n\n    return (\n        <Container>\n            {![\"PresentingSummary\", \"Completed\"].includes(gameState?.gameStatus) && <ControlPanel>\n                <ClearButton />\n                <ColorPicker color={activeColor} onChange={setActiveColor} />\n                <StrokeWidth />\n                <ColorPalette />\n                <LayerList />                \n            </ControlPanel>}\n        </Container>\n    )\n}","/home/rollie/repos/drawing-app/frontend/src/Components/RightSide.js",["194","195","196"],"import React from 'react'\nimport styled from 'styled-components'\nimport LayerBox from './LayerBox'\nimport { ImageButton, Button } from '../Controls'\nimport { getDrawing } from './Canvas'\nimport { sleep } from '../Utils'\nimport StartButtonImg from '../images/start-button.png'\nimport * as GameApi from '../GameApi'\nimport * as Context from '../Context'\n\nconst RightSideContainer = styled.div`\n`\n\nconst GameButtons = styled.div`\n`\n\n\nconst ActionButton = styled(Button)`\n    font-size: 28px;  \n`\n\nfunction DoneButton() {\n    const [user] = React.useContext(Context.UserContext)\n    const [activeBook, setActiveBook] = React.useContext(Context.ActiveBookContext)\n    const [gameState] = React.useContext(Context.GameStateContext)\n    const [description] = React.useContext(Context.DescriptionContext)\n    const [replayDrawings, setReplayDrawings] = React.useContext(Context.ReplayDrawingsContext)\n    const [layers] = React.useContext(Context.LayerContext)\n    const [, setRecentSubmission] = React.useContext(Context.RecentSubmissionContext)\n\n    console.log(activeBook, activeBook?.entries)\n    const handler = async () => {\n        if (activeBook?.entries && activeBook.entries.length % 2 === 1) {            \n            const data = getDrawing(layers)\n            for (const replay of replayDrawings) {\n                replay.drawParams.layerCanvas = undefined\n                replay.drawParams.workingCanvas = undefined\n            }\n\n            console.log(replayDrawings)\n\n            const resp = await GameApi.UploadDrawing(data, gameState.id, activeBook.creator.name, JSON.stringify(replayDrawings), user)\n            console.log(resp)\n            if (resp) { // TODO\n                setRecentSubmission(activeBook.creator.name)    \n            }\n            setReplayDrawings([])\n        } else {\n            await GameApi.UploadDescription(description, gameState.id, activeBook.creator.name, user)\n        }\n        setActiveBook(null)\n    }\n\n    return (\n        <ActionButton onClick={handler}>Done</ActionButton>\n    )\n}\n\nconst UndoSubmitButtonStyled = styled(ActionButton)`\n    display: none;\n\n    &.showing {\n        display: block;\n        opacity: 1;\n    }\n\n    &.hiding {\n        display: block;\n        transition: opacity 2.0s ease-out;\n        opacity: 0;\n    }\n`\n\nfunction UndoSubmitButton() {\n    const [gameState, setGameState] = React.useContext(Context.GameStateContext)\n    const [user] = React.useContext(Context.UserContext)\n    const [recentSubmission, setRecentSubmission] = React.useContext(Context.RecentSubmissionContext)\n    const [, setActiveBook] = React.useContext(Context.ActiveBookContext)\n    const [, setDescription] = React.useContext(Context.DescriptionContext)\n    const [, setStaticImage] = React.useContext(Context.StaticImageContext)\n    const [className, setClassName] = React.useState(\"\")\n\n    React.useEffect(() => {\n        const handler = async () => {\n            if (recentSubmission) {\n                // Show\n                await sleep(300)\n                setClassName('showing')\n                await sleep(4000)\n                setClassName('hiding')\n\n                await sleep(2000)\n                setClassName('')\n                \n                await sleep(4000)                \n\n                //setRecentSubmission((recentSubmission ?? 'x') + '1') // Testing\n                setRecentSubmission(undefined)\n            }\n        }\n\n        handler()\n    }, [recentSubmission])\n\n    const undoSubmission = React.useCallback(() => {\n        const handler = async () => {\n            const result = await GameApi.UndoSubmission(gameState.id, recentSubmission, user)\n            if (result.success) {\n                const data = result.data\n                const gameState = result.gameState\n                // Normally we let the websocket propagate this, but we need to keep the newly active book in\n                // sync with the game state, so we need to set them together.\n                setGameState(result.gameState)\n                const book = gameState.books.find(book => book.creator.name === recentSubmission)\n                setActiveBook(book)\n                \n                if (data.imageUrl) {\n                    // Image entry\n                    setStaticImage(data.imageUrl)\n                } else {\n                    // Description entry\n                    setStaticImage('empty')\n                }\n            }\n        }\n\n        handler()\n    }, [gameState, recentSubmission, user])\n\n    return (\n        <>\n            <UndoSubmitButtonStyled onClick={undoSubmission} className={className}>Undo</UndoSubmitButtonStyled>\n        </>\n    )\n}\n\nexport default function RightSide() {\n    const [user] = React.useContext(Context.UserContext)\n    const [gameState] = React.useContext(Context.GameStateContext)\n    const [activeBook] = React.useContext(Context.ActiveBookContext)\n\n    const startGame = async () => {\n        await GameApi.StartGame(gameState.id, { rounds: gameState.players.length }, user)\n    }\n\n    const startPresentation = async () => {\n        await GameApi.StartPresentation(gameState.id, user)\n    }\n\n    const presentNext = async () => {\n        await GameApi.PresentNext(gameState.id, user)\n    }\n\n    const viewGameSummary = async () => {\n        await GameApi.EndGame(gameState.id, user)\n    }\n\n    const readyToPresent = gameState && gameState.gameStatus === \"InProgress\" && !gameState.books.some(book => book.currentActor())\n    const isGameOwner = gameState?.isOwner(user)\n\n    return (\n        <RightSideContainer>\n            <LayerBox />\n            <GameButtons>\n                {isGameOwner && \n                <>\n                    {readyToPresent && \n                        <ActionButton onClick={startPresentation}>Start Presenting</ActionButton>}\n                    {gameState.isNotStarted() && \n                        <ImageButton onClick={startGame} height=\"120px\" image={StartButtonImg} />                \n                    }\n                    {gameState.isPresenting() && !gameState.isDonePresenting() && \n                        <ActionButton onClick={presentNext}>Present Next</ActionButton>}\n                    {gameState.isDonePresenting() && \n                        <ActionButton onClick={viewGameSummary}>View Game Summary</ActionButton>}\n                </>}\n            \n                {activeBook && <DoneButton />}\n                <UndoSubmitButton />\n            </GameButtons>\n        </RightSideContainer>\n    )\n}","/home/rollie/repos/drawing-app/frontend/src/DrawingContext.js",[],"/home/rollie/repos/drawing-app/frontend/src/Components/Turorial.js",["197","198","199","200","201","202"],"import React from 'react';\nimport styled from 'styled-components'\nimport * as Context from '../Context'\nimport * as GameApi from '../GameApi'\nimport Modal from 'react-modal';\nimport { Button } from '../Controls'\nimport {DialogContainer, DialogContent, DialogHeader} from './GameDialogs'\nimport TutorialImg from '../images/tutorial.png'\n\n/* Help text\n\nThese are your drawing controls!\n\nThey can be selected by click on them, or by using hotkeys QWERASD (in order)\n\n*/\n\nconst TutorialContent = styled.div`\n    display: flex;\n    justify-content: center;\n    margin: 60px;\n`\nexport function TutorialDialog(props) {\n    const { open, setOpen } = props\n    const handleClose = () => { setOpen(false); };\n\n    return (\n        <DialogContainer onRequestClose={handleClose} aria-labelledby=\"customized-dialog-title\" isOpen={open}>\n            <DialogHeader onClose={handleClose}>\n                How to Play\n            </DialogHeader>\n            <TutorialContent>\n                <img src={TutorialImg} width={\"80%\"} />\n                <br/>\n                {/* <Button onClick={handleClose}>Next</Button> */}\n            </TutorialContent>\n        </DialogContainer>\n    );\n}",{"ruleId":"203","replacedBy":"204"},{"ruleId":"205","replacedBy":"206"},{"ruleId":"207","severity":1,"message":"208","line":19,"column":11,"nodeType":"209","messageId":"210","endLine":19,"endColumn":19},{"ruleId":"203","replacedBy":"211"},{"ruleId":"205","replacedBy":"212"},{"ruleId":"213","severity":1,"message":"214","line":31,"column":6,"nodeType":"215","endLine":31,"endColumn":8,"suggestions":"216"},{"ruleId":"213","severity":1,"message":"217","line":45,"column":6,"nodeType":"215","endLine":45,"endColumn":29,"suggestions":"218"},{"ruleId":"207","severity":1,"message":"219","line":67,"column":9,"nodeType":"209","messageId":"210","endLine":67,"endColumn":22},{"ruleId":"207","severity":1,"message":"220","line":82,"column":10,"nodeType":"209","messageId":"210","endLine":82,"endColumn":23},{"ruleId":"213","severity":1,"message":"221","line":102,"column":20,"nodeType":"209","endLine":102,"endColumn":29},{"ruleId":"207","severity":1,"message":"222","line":1,"column":17,"nodeType":"209","messageId":"210","endLine":1,"endColumn":26},{"ruleId":"207","severity":1,"message":"223","line":5,"column":8,"nodeType":"209","messageId":"210","endLine":5,"endColumn":24},{"ruleId":"207","severity":1,"message":"224","line":15,"column":8,"nodeType":"209","messageId":"210","endLine":15,"endColumn":15},{"ruleId":"207","severity":1,"message":"225","line":16,"column":8,"nodeType":"209","messageId":"210","endLine":16,"endColumn":15},{"ruleId":"207","severity":1,"message":"226","line":23,"column":10,"nodeType":"209","messageId":"210","endLine":23,"endColumn":20},{"ruleId":"213","severity":1,"message":"227","line":96,"column":8,"nodeType":"215","endLine":96,"endColumn":51,"suggestions":"228"},{"ruleId":"213","severity":1,"message":"229","line":149,"column":8,"nodeType":"215","endLine":149,"endColumn":78,"suggestions":"230"},{"ruleId":"207","severity":1,"message":"231","line":4,"column":13,"nodeType":"209","messageId":"210","endLine":4,"endColumn":20},{"ruleId":"207","severity":1,"message":"232","line":7,"column":23,"nodeType":"209","messageId":"210","endLine":7,"endColumn":29},{"ruleId":"207","severity":1,"message":"233","line":99,"column":7,"nodeType":"209","messageId":"210","endLine":99,"endColumn":10},{"ruleId":"213","severity":1,"message":"227","line":59,"column":8,"nodeType":"215","endLine":59,"endColumn":20,"suggestions":"234"},{"ruleId":"213","severity":1,"message":"235","line":107,"column":8,"nodeType":"215","endLine":107,"endColumn":36,"suggestions":"236"},{"ruleId":"213","severity":1,"message":"237","line":148,"column":8,"nodeType":"215","endLine":148,"endColumn":10,"suggestions":"238"},{"ruleId":"207","severity":1,"message":"239","line":153,"column":7,"nodeType":"209","messageId":"210","endLine":153,"endColumn":32},{"ruleId":"207","severity":1,"message":"240","line":180,"column":7,"nodeType":"209","messageId":"210","endLine":180,"endColumn":26},{"ruleId":"213","severity":1,"message":"241","line":245,"column":8,"nodeType":"215","endLine":245,"endColumn":31,"suggestions":"242"},{"ruleId":"213","severity":1,"message":"243","line":259,"column":8,"nodeType":"215","endLine":259,"endColumn":21,"suggestions":"244"},{"ruleId":"213","severity":1,"message":"243","line":273,"column":8,"nodeType":"215","endLine":273,"endColumn":19,"suggestions":"245"},{"ruleId":"207","severity":1,"message":"246","line":94,"column":7,"nodeType":"209","messageId":"210","endLine":94,"endColumn":20},{"ruleId":"247","severity":1,"message":"248","line":15,"column":13,"nodeType":"249","endLine":15,"endColumn":48},{"ruleId":"207","severity":1,"message":"250","line":91,"column":69,"nodeType":"209","messageId":"210","endLine":91,"endColumn":74},{"ruleId":"213","severity":1,"message":"251","line":238,"column":12,"nodeType":"215","endLine":238,"endColumn":29,"suggestions":"252"},{"ruleId":"213","severity":1,"message":"253","line":238,"column":13,"nodeType":"254","endLine":238,"endColumn":20},{"ruleId":"207","severity":1,"message":"255","line":285,"column":11,"nodeType":"209","messageId":"210","endLine":285,"endColumn":22},{"ruleId":"213","severity":1,"message":"256","line":337,"column":8,"nodeType":"215","endLine":337,"endColumn":100,"suggestions":"257"},{"ruleId":"213","severity":1,"message":"258","line":370,"column":8,"nodeType":"215","endLine":370,"endColumn":10,"suggestions":"259"},{"ruleId":"213","severity":1,"message":"260","line":540,"column":8,"nodeType":"215","endLine":540,"endColumn":46,"suggestions":"261"},{"ruleId":"207","severity":1,"message":"262","line":2,"column":8,"nodeType":"209","messageId":"210","endLine":2,"endColumn":16},{"ruleId":"213","severity":1,"message":"263","line":33,"column":8,"nodeType":"215","endLine":33,"endColumn":15,"suggestions":"264"},{"ruleId":"213","severity":1,"message":"265","line":46,"column":8,"nodeType":"215","endLine":46,"endColumn":26,"suggestions":"266"},{"ruleId":"207","severity":1,"message":"267","line":4,"column":8,"nodeType":"209","messageId":"210","endLine":4,"endColumn":13},{"ruleId":"207","severity":1,"message":"268","line":20,"column":7,"nodeType":"209","messageId":"210","endLine":20,"endColumn":12},{"ruleId":"207","severity":1,"message":"269","line":1,"column":22,"nodeType":"209","messageId":"210","endLine":1,"endColumn":36},{"ruleId":"207","severity":1,"message":"270","line":1,"column":46,"nodeType":"209","messageId":"210","endLine":1,"endColumn":53},{"ruleId":"207","severity":1,"message":"271","line":226,"column":12,"nodeType":"209","messageId":"210","endLine":226,"endColumn":23},{"ruleId":"207","severity":1,"message":"272","line":226,"column":25,"nodeType":"209","messageId":"210","endLine":226,"endColumn":38},{"ruleId":"207","severity":1,"message":"222","line":1,"column":17,"nodeType":"209","messageId":"210","endLine":1,"endColumn":26},{"ruleId":"207","severity":1,"message":"273","line":4,"column":8,"nodeType":"209","messageId":"210","endLine":4,"endColumn":20},{"ruleId":"207","severity":1,"message":"274","line":5,"column":8,"nodeType":"209","messageId":"210","endLine":5,"endColumn":25},{"ruleId":"207","severity":1,"message":"275","line":6,"column":9,"nodeType":"209","messageId":"210","endLine":6,"endColumn":14},{"ruleId":"207","severity":1,"message":"276","line":7,"column":10,"nodeType":"209","messageId":"210","endLine":7,"endColumn":21},{"ruleId":"277","severity":1,"message":"278","line":75,"column":64,"nodeType":"279","messageId":"280","endLine":75,"endColumn":66},{"ruleId":"213","severity":1,"message":"281","line":76,"column":8,"nodeType":"215","endLine":76,"endColumn":35,"suggestions":"282"},{"ruleId":"213","severity":1,"message":"283","line":121,"column":8,"nodeType":"215","endLine":121,"endColumn":20,"suggestions":"284"},{"ruleId":"207","severity":1,"message":"285","line":138,"column":7,"nodeType":"209","messageId":"210","endLine":138,"endColumn":23},{"ruleId":"207","severity":1,"message":"286","line":165,"column":15,"nodeType":"209","messageId":"210","endLine":165,"endColumn":18},{"ruleId":"277","severity":1,"message":"287","line":212,"column":67,"nodeType":"279","messageId":"280","endLine":212,"endColumn":69},{"ruleId":"213","severity":1,"message":"288","line":220,"column":8,"nodeType":"215","endLine":220,"endColumn":16,"suggestions":"289"},{"ruleId":"213","severity":1,"message":"288","line":259,"column":8,"nodeType":"215","endLine":259,"endColumn":16,"suggestions":"290"},{"ruleId":"213","severity":1,"message":"288","line":270,"column":8,"nodeType":"215","endLine":270,"endColumn":16,"suggestions":"291"},{"ruleId":"213","severity":1,"message":"292","line":295,"column":8,"nodeType":"215","endLine":295,"endColumn":18,"suggestions":"293"},{"ruleId":"213","severity":1,"message":"294","line":301,"column":8,"nodeType":"215","endLine":301,"endColumn":29,"suggestions":"295"},{"ruleId":"207","severity":1,"message":"296","line":325,"column":7,"nodeType":"209","messageId":"210","endLine":325,"endColumn":21},{"ruleId":"213","severity":1,"message":"297","line":356,"column":8,"nodeType":"215","endLine":356,"endColumn":16,"suggestions":"298"},{"ruleId":"207","severity":1,"message":"299","line":374,"column":11,"nodeType":"209","messageId":"210","endLine":374,"endColumn":28},{"ruleId":"207","severity":1,"message":"300","line":79,"column":14,"nodeType":"209","messageId":"210","endLine":79,"endColumn":28},{"ruleId":"213","severity":1,"message":"301","line":103,"column":8,"nodeType":"215","endLine":103,"endColumn":26,"suggestions":"302"},{"ruleId":"213","severity":1,"message":"303","line":128,"column":8,"nodeType":"215","endLine":128,"endColumn":43,"suggestions":"304"},{"ruleId":"207","severity":1,"message":"305","line":3,"column":13,"nodeType":"209","messageId":"210","endLine":3,"endColumn":20},{"ruleId":"207","severity":1,"message":"231","line":4,"column":13,"nodeType":"209","messageId":"210","endLine":4,"endColumn":20},{"ruleId":"207","severity":1,"message":"267","line":5,"column":8,"nodeType":"209","messageId":"210","endLine":5,"endColumn":13},{"ruleId":"207","severity":1,"message":"232","line":6,"column":10,"nodeType":"209","messageId":"210","endLine":6,"endColumn":16},{"ruleId":"207","severity":1,"message":"306","line":7,"column":26,"nodeType":"209","messageId":"210","endLine":7,"endColumn":39},{"ruleId":"247","severity":1,"message":"248","line":33,"column":17,"nodeType":"249","endLine":33,"endColumn":56},"no-native-reassign",["307"],"no-negated-in-lhs",["308"],"no-unused-vars","'atrament' is assigned a value but never used.","Identifier","unusedVar",["307"],["308"],"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'setGameState' and 'setUser'. Either include them or remove the dependency array.","ArrayExpression",["309"],"React Hook useEffect has a missing dependency: 'setGameState'. Either include it or remove the dependency array.",["310"],"'prevGameState' is assigned a value but never used.","'useActiveBook' is defined but never used.","Assignments to the 'activeBook' variable from inside React Hook React.useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside React.useEffect.","'useEffect' is defined but never used.","'GameStateDetails' is defined but never used.","'UndoImg' is defined but never used.","'RedoImg' is defined but never used.","'withStyles' is defined but never used.","React Hook useEffect has a missing dependency: 'setDescription'. Either include it or remove the dependency array.",["311"],"React Hook useEffect has a missing dependency: 'setStaticImage'. Either include it or remove the dependency array.",["312"],"'GameApi' is defined but never used.","'Button' is defined but never used.","'SVG' is assigned a value but never used.",["313"],"React Hook React.useEffect has a missing dependency: 'setActiveColor'. Either include it or remove the dependency array.",["314"],"React Hook useEffect has missing dependencies: 'props', 'setActiveTool', 'setRequestCopy', 'setRequestDelete', 'setRequestPaste', 'setRequestRedo', and 'setRequestUndo'. Either include them or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.",["315"],"'ConvasBackgroundContainer' is assigned a value but never used.","'RequestReplayButton' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'canvasProps'. Either include it or remove the dependency array.",["316"],"React Hook React.useCallback has a missing dependency: 'canvasProps'. Either include it or remove the dependency array.",["317"],["318"],"'DialogControl' is assigned a value but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","'shape' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'fn'. Either include it or remove the dependency array. Outer scope values like 'layers' aren't valid dependencies because mutating them doesn't re-render the component.",["319"],"React Hook useEffect has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies.","SpreadElement","'enrichProps' is assigned a value but never used.","React Hook React.useCallback has missing dependencies: 'activeLayerCanvasRef', 'getCanvases', 'pushAction', 'uiCanvasRef', and 'workingCanvasRef'. Either include them or remove the dependency array.",["320"],"React Hook useEffect has missing dependencies: 'layers', 'setCanvas', and 'uiCanvasRef'. Either include them or remove the dependency array.",["321"],"React Hook React.useCallback has an unnecessary dependency: 'layers'. Either exclude it or remove the dependency array.",["322"],"'ReactDOM' is defined but never used.","React Hook useEffect has a missing dependency: 'curState'. Either include it or remove the dependency array.",["323"],"React Hook React.useEffect has a missing dependency: 'handler'. Either include it or remove the dependency array. If 'handler' changes too often, find the parent component that defines it and wrap that definition in useCallback.",["324"],"'Modal' is defined but never used.","'clear' is assigned a value but never used.","'MouseEventType' is defined but never used.","'_getPos' is defined but never used.","'layerCanvas' is assigned a value but never used.","'workingCanvas' is assigned a value but never used.","'ToggleButton' is defined but never used.","'ToggleButtonGroup' is defined but never used.","'sleep' is defined but never used.","'DrawingMode' is defined but never used.","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","React Hook React.useCallback has missing dependencies: 'props.color', 'setActiveColor', and 'setColorPalette'. Either include them or remove the dependency array.",["325"],"React Hook React.useEffect has a missing dependency: 'setColorPalette'. Either include it or remove the dependency array.",["326"],"'StrokeWidthValue' is assigned a value but never used.","'val' is assigned a value but never used.","Expected '===' and instead saw '=='.","React Hook React.useCallback has missing dependencies: 'layer', 'pushAction', and 'setLayers'. Either include them or remove the dependency array.",["327"],["328"],["329"],"React Hook React.useEffect has a missing dependency: 'layer.name'. Either include it or remove the dependency array. If 'setLayerName' needs the current value of 'layer.name', you can also switch to useReducer instead of useState and read 'layer.name' in the reducer.",["330"],"React Hook React.useEffect has a missing dependency: 'layer'. Either include it or remove the dependency array.",["331"],"'NewLayerButton' is assigned a value but never used.","React Hook React.useCallback has missing dependencies: 'pushAction' and 'setLayers'. Either include them or remove the dependency array.",["332"],"'presentingSummary' is assigned a value but never used.","'setDescription' is assigned a value but never used.","React Hook React.useEffect has a missing dependency: 'setRecentSubmission'. Either include it or remove the dependency array.",["333"],"React Hook React.useCallback has missing dependencies: 'setActiveBook', 'setGameState', and 'setStaticImage'. Either include them or remove the dependency array.",["334"],"'Context' is defined but never used.","'DialogContent' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"335","fix":"336"},{"desc":"337","fix":"338"},{"desc":"339","fix":"340"},{"desc":"341","fix":"342"},{"desc":"343","fix":"344"},{"desc":"345","fix":"346"},{"desc":"347","fix":"348"},{"desc":"349","fix":"350"},{"desc":"351","fix":"352"},{"desc":"353","fix":"354"},{"desc":"355","fix":"356"},{"desc":"357","fix":"358"},{"desc":"359","fix":"360"},{"desc":"361","fix":"362"},{"desc":"363","fix":"364"},{"desc":"365","fix":"366"},{"desc":"367","fix":"368"},{"desc":"369","fix":"370"},{"desc":"371","fix":"372"},{"desc":"371","fix":"373"},{"desc":"371","fix":"374"},{"desc":"375","fix":"376"},{"desc":"377","fix":"378"},{"desc":"379","fix":"380"},{"desc":"381","fix":"382"},{"desc":"383","fix":"384"},"Update the dependencies array to be: [setGameState, setUser]",{"range":"385","text":"386"},"Update the dependencies array to be: [gameState, setGameState, subscribed]",{"range":"387","text":"388"},"Update the dependencies array to be: [entry.description, gameState, label, name, setDescription]",{"range":"389","text":"390"},"Update the dependencies array to be: [entry.imageUrl, gameState, label, name, presentationState.pageNumber, setStaticImage]",{"range":"391","text":"392"},"Update the dependencies array to be: [activeBook, setDescription]",{"range":"393","text":"394"},"Update the dependencies array to be: [colorPalette, pushedNumber, setActiveColor]",{"range":"395","text":"396"},"Update the dependencies array to be: [props, setActiveTool, setRequestCopy, setRequestDelete, setRequestPaste, setRequestRedo, setRequestUndo]",{"range":"397","text":"398"},"Update the dependencies array to be: [gameState, activeBook, canvasProps]",{"range":"399","text":"400"},"Update the dependencies array to be: [activeColor, canvasProps]",{"range":"401","text":"402"},"Update the dependencies array to be: [canvasProps, gameState.books, gameState.presentationState]",{"range":"403","text":"404"},"Update the dependencies array to be: [fn]",{"range":"405","text":"406"},"Update the dependencies array to be: [staticImage, activeLayerCanvasRef, workingCanvasRef, mode, shape, pushAction, getCanvases, onDraw, uiCanvasRef]",{"range":"407","text":"408"},"Update the dependencies array to be: [layers, setCanvas, uiCanvasRef]",{"range":"409","text":"410"},"Update the dependencies array to be: [activeColor, lineWidth, mode]",{"range":"411","text":"412"},"Update the dependencies array to be: [curState, state]",{"range":"413","text":"414"},"Update the dependencies array to be: [state, prevState, handler]",{"range":"415","text":"416"},"Update the dependencies array to be: [setActiveColor, props.color, setColorPalette, colorPalette]",{"range":"417","text":"418"},"Update the dependencies array to be: [activeBook, setColorPalette]",{"range":"419","text":"420"},"Update the dependencies array to be: [layer, layers, pushAction, setLayers]",{"range":"421","text":"422"},{"range":"423","text":"422"},{"range":"424","text":"422"},"Update the dependencies array to be: [layer.name, renaming]",{"range":"425","text":"426"},"Update the dependencies array to be: [renaming, layerName, layer]",{"range":"427","text":"428"},"Update the dependencies array to be: [layers, pushAction, setLayers]",{"range":"429","text":"430"},"Update the dependencies array to be: [recentSubmission, setRecentSubmission]",{"range":"431","text":"432"},"Update the dependencies array to be: [gameState.id, recentSubmission, setActiveBook, setGameState, setStaticImage, user]",{"range":"433","text":"434"},[1064,1066],"[setGameState, setUser]",[1460,1483],"[gameState, setGameState, subscribed]",[2993,3036],"[entry.description, gameState, label, name, setDescription]",[4812,4882],"[entry.imageUrl, gameState, label, name, presentationState.pageNumber, setStaticImage]",[1597,1609],"[activeBook, setDescription]",[3140,3168],"[colorPalette, pushedNumber, setActiveColor]",[4626,4628],"[props, setActiveTool, setRequestCopy, setRequestDelete, setRequestPaste, setRequestRedo, setRequestUndo]",[7256,7279],"[gameState, activeBook, canvasProps]",[7751,7764],"[activeColor, canvasProps]",[8372,8383],"[canvasProps, gameState.books, gameState.presentationState]",[8014,8031],"[fn]",[11209,11301],"[staticImage, activeLayerCanvasRef, workingCanvasRef, mode, shape, pushAction, getCanvases, onDraw, uiCanvasRef]",[12753,12755],"[layers, setCanvas, uiCanvasRef]",[19590,19628],"[activeColor, lineWidth, mode]",[914,921],"[curState, state]",[1166,1184],"[state, prevState, handler]",[2507,2534],"[setActiveColor, props.color, setColorPalette, colorPalette]",[3699,3711],"[activeBook, setColorPalette]",[6207,6215],"[layer, layers, pushAction, setLayers]",[7260,7268],[7586,7594],[8413,8423],"[layer.name, renaming]",[8531,8552],"[renaming, layerName, layer]",[10132,10140],"[layers, pushAction, setLayers]",[3427,3445],"[recentSubmission, setRecentSubmission]",[4445,4480],"[gameState.id, recentSubmission, setActiveBook, setGameState, setStaticImage, user]"]